{"path":"sem5/CD/Module 2_I.pdf","text":"BCSE307L – COMPILER DESIGN 1Dr. SUGANTHINI. C, SCOPE, VIT 2Dr. SUGANTHINI. C, SCOPE, VIT Syntax analysis Introduction to Syntax Analysis CFG Types of Parser 3Dr. SUGANTHINI. C, SCOPE, VIT The role of parser Lexical Analyzer ParserSource program token getNext Token Symbol table Parse tree Rest of Front End Intermediate representation • Parser works on a stream of tokens. • The smallest item is a token. 4Dr. SUGANTHINI. C, SCOPE, VIT Syntax Analyzer Syntax Analyzer creates the syntactic structure of the given source program. This syntactic structure is mostly a parse tree. Syntax Analyzer is also known as parser. The syntax of a programming is described by a context-free grammar (CFG). 5Dr. SUGANTHINI. C, SCOPE, VIT Syntax Analyzer The syntax analyzer (parser) checks whether a given source program satisfies the rules implied by a context-free grammar or not. ◦ If it satisfies, the parser creates the parse tree of that program. ◦ Otherwise the parser gives the error messages. A context-free grammar ◦ gives a precise syntactic specification of a programming language. ◦ the design of the grammar is an initial phase of the design of a compiler. ◦ a grammar can be directly converted into a parser by some tools. 6Dr. SUGANTHINI. C, SCOPE, VIT Expression Grammar 7Dr. SUGANTHINI. C, SCOPE, VIT 8 Parsers We categorize the parsers into two groups: 1. Top-Down Parser ◦ the parse tree is created top to bottom, starting from the root. 2. Bottom-Up Parser ◦ the parse is created bottom to top; starting from the leaves Both top-down and bottom-up parsers scan the input from left to right (one symbol at a time). Efficient top-down and bottom-up parsers can be implemented only for sub-classes of context-free grammars. ◦ LL for top-down parsing ◦ LR for bottom-up parsing Dr. SUGANTHINI. C, SCOPE, VIT Syntax Tree A parse tree is a record of the rules (and tokens) used to match some input text A syntax tree records the structure of the input and is insensitive to the grammar that produced it. 9Dr. SUGANTHINI. C, SCOPE, VIT 10Dr. SUGANTHINI. C, SCOPE, VIT 11Dr. SUGANTHINI. C, SCOPE, VIT CONTEXT FREE GRAMMAR (CFG) ❑The formal definition of a context-free grammar ❑Notational Conventions ❑Derivations ❑Parse Tree and Derivations ❑Ambiguity ❑Verifying the language generated by a Grammar ❑Context-free grammar versus regular expression 12Dr. SUGANTHINI. C, SCOPE, VIT Context-Free Grammars Inherently recursive structures of a programming language are defined by a context-free grammar. In a context-free grammar G = (V,T,P,S), we have: ◦ T - A finite set of terminals (in our case, this will be the set of tokens) ◦ V - A finite set of non-terminals (syntactic-variables) ◦ P - A finite set of productions rules in the following form ◦ A →  where A is a non-terminal and  is a string of terminals and non-terminals (including the empty string) ◦ S - A start symbol (one of the non-terminal symbol) 13Dr. SUGANTHINI. C, SCOPE, VIT Notational Conventions 14Dr. SUGANTHINI. C, SCOPE, VIT 15 Notational Conventions Dr. SUGANTHINI. C, SCOPE, VIT Example 16Dr. SUGANTHINI. C, SCOPE, VIT Expression Grammar Example: E → E + E | E – E | E * E | E / E | - E E → ( E ) E → id 17Dr. SUGANTHINI. C, SCOPE, VIT CFG - Terminology L(G) is the language of G (the language generated by G) which is a set of sentences. A sentence of L(G) is a string of terminal symbols of G. If S is the start symbol of G then  is a sentence of L(G) iff S   where  is a string of terminals of G. If G is a context-free grammar, L(G) is a context-free language. Two grammars are equivalent if they produce the same language. S   - If  contains non-terminals, it is called as a sentential form of G. - If  does not contain non-terminals, it is called as a sentence of G. + * 18Dr. SUGANTHINI. C, SCOPE, VIT Derivations A sequence of replacements of non-terminal symbols is called a derivation of id+id from E. 1  2  ...  n (n derives from 1 or 1 derives n )  : derives in one step  : derives in zero or more steps  : derives in one or more steps * + 19Dr. SUGANTHINI. C, SCOPE, VIT Derivations 20Dr. SUGANTHINI. C, SCOPE, VIT Derivations E  E+E E+E derives from E ◦ we can replace E by E+E ◦ to able to do this, we have to have a production rule E→E+E in our grammar. E  E+E  id+E  id+id 21Dr. SUGANTHINI. C, SCOPE, VIT Derivation Example E  -E  -(E)  -(E+E)  -(id+E)  -(id+id) OR E  -E  -(E)  -(E+E)  -(E+id)  -(id+id) At each derivation step, we can choose any of the non-terminal in the sentential form of G for the replacement. If we always choose the left-most non-terminal in each derivation step, this derivation is called as left-most derivation. If we always choose the right-most non-terminal in each derivation step, this derivation is called as right-most derivation. 22Dr. SUGANTHINI. C, SCOPE, VIT Left-Most and Right-Most Derivations Left-Most Derivation E  -E  -(E)  -(E+E)  -(id+E)  -(id+id) Right-Most Derivation E  -E  -(E)  -(E+E)  -(E+id)  -(id+id) We will see that the top-down parsers try to find the left-most derivation of the given source program. We will see that the bottom-up parsers try to find the right-most derivation of the given source program in the reverse order. lmlmlmlmlm rmrmrmrmrm 23Dr. SUGANTHINI. C, SCOPE, VIT Parse Tree • Inner nodes of a parse tree are non-terminal symbols. • The leaves of a parse tree are terminal symbols. • A parse tree can be seen as a graphical representation of a derivation. E  -E E E- E E EE E + - ( ) E E E- ( ) E E id E E E + - ( ) id E E E EE + - ( ) id  -(E)  -(E+E)  -(id+E)  -(id+id) 24Dr. SUGANTHINI. C, SCOPE, VIT Ambiguity • A grammar produces more than one parse tree for a sentence is called as an ambiguous grammar. E  E+E  id+E  id+E*E  id+id*E  id+id*id E  E*E  E+E*E  id+E*E  id+id*E  id+id*id E id E + id id E E * E E E + id E E * E id id 25 Ambiguous: Two Different Parse Tree: Dr. SUGANTHINI. C, SCOPE, VIT Ambiguity Ambiguous: Two Different Parse Tree: if E1 then if E2 then S1 else S2 One Parse Tree: if E1 then S1 else if E2 then S2 else S3 26Dr. SUGANTHINI. C, SCOPE, VIT Ambiguity For the most parsers, the grammar must be unambiguous. unambiguous grammar ➔ unique selection of the parse tree for a sentence We should eliminate the ambiguity in the grammar during the design phase of the compiler. An unambiguous grammar should be written to eliminate the ambiguity. We have to prefer one of the parse trees of a sentence (generated by an ambiguous grammar) to disambiguate that grammar to restrict to this choice. 27Dr. SUGANTHINI. C, SCOPE, VIT Verifying the language generated by a Grammar Expression S → (S) S | Ɛ S  (S) S (x)S  (x)y Checking the string (x)y is balanced with equal number of right and left parentheses and every prefix has at least as many left parentheses as right w  (x)y is also derivable form S. 28 lmlm lm Dr. SUGANTHINI. C, SCOPE, VIT Context-free grammar versus regular expression R.E = (a|b)*abb CFG: S → aS | bS | aA A → bB B → bC C → Ɛ 29Dr. SUGANTHINI. C, SCOPE, VIT Writing a Grammar ❑Lexical versus Syntactic Analysis ❑Eliminating Ambiguity ❑Elimination of Left Recursion ❑Elimination of left Factoring 30Dr. SUGANTHINI. C, SCOPE, VIT Elimination of ambiguity Idea: ◦ A statement appearing between a then and an else must be matched (Match each else with the closest previous unmatched then ) 31Dr. SUGANTHINI. C, SCOPE, VIT Ambiguity • We prefer the first parse tree (else matches with closest if). • So, we have to disambiguate our grammar to reflect this choice. • The unambiguous grammar will be: stmt → matched_stmt | unmatched_stmt matchedstmt → if expr then matched_stmt else matchedstmt | otherstmts unmatchedstmt → if expr then stmt | if expr then matched_stmt else unmatched_stmt 32Dr. SUGANTHINI. C, SCOPE, VIT Expression Grammar Example: E → E + E | E – E | E * E | E / E | - E E → ( E ) E → id 33Dr. SUGANTHINI. C, SCOPE, VIT Simple Arithmetic Expression (Unambiguous Expression) Grammar expr → expr + term expr → expr - term expr → term term → term * factor term → term / factor term → factor factor → (expr) factor → id 34Dr. SUGANTHINI. C, SCOPE, VIT Unambiguous Expression Grammar E → E + T | E – T | T T → T * F | T / F | F F → ( E ) F → id 35Dr. SUGANTHINI. C, SCOPE, VIT Left Recursion A grammar is left recursive if it has a non-terminal A such that there is a derivation. A  A for some string  Top-down parsing techniques cannot handle left-recursive grammars. So, we have to convert our left-recursive grammar into an equivalent grammar which is not left-recursive. The left-recursion may appear in a single step of the derivation (immediate left- recursion), or may appear in more than one step of the derivation. + 36Dr. SUGANTHINI. C, SCOPE, VIT Immediate Left-Recursion A → A  |  where  does not start with A  eliminate immediate left recursion A →  A’ A’ →  A’ |  an equivalent grammar A → A 1 | ... | A m | 1 | ... | n where 1 ... n do not start with A  eliminate immediate left recursion A → 1 A’ | ... | n A’ A’ → 1 A’ | ... | m A’ |  an equivalent grammar In general, 37Dr. SUGANTHINI. C, SCOPE, VIT Immediate Left-Recursion -- Example E → E+T | T T → T*F | F F → (E) F → id E → T E’ E’ → +T E’ |  T → F T’ T’ → *F T’ |  F → (E) F → id eliminate immediate left recursion  38Dr. SUGANTHINI. C, SCOPE, VIT 39Dr. SUGANTHINI. C, SCOPE, VIT Apply Left recursion for this example: 40 E → E + T | E – T | T T → T * F | T / F | F F → ( E ) F → id Dr. SUGANTHINI. C, SCOPE, VIT 41 LHS → RHS S → P1 | P2 | P3 | …. | Pn Rule: A → A  |   A →  A’ A’ →  A’ |  Elimination of left recursion Dr. SUGANTHINI. C, SCOPE, VIT Example 2 S → Aa | b A → Ac | Sd |  42Dr. SUGANTHINI. C, SCOPE, VIT Example 2 S → Aa | b A → Ac | Sd |   A → Ac | Aad | bd |  A → A1 |A2 | 1 | 2  S → Aa | b A → bdA’ | A’ A’ → cA’ | adA’ |  43Dr. SUGANTHINI. C, SCOPE, VIT Elimination of Left Factoring 44 A predictive parser (a top-down parser without backtracking) insists that the grammar must be left-factored. grammar ➔ a new equivalent grammar suitable for predictive parsing stmt → if expr then stmt else stmt | if expr then stmt Dr. SUGANTHINI. C, SCOPE, VIT Elimination of Left-Factoring In general, A → 1 | 2 where  is non-empty and the first symbols of 1 and 2 (if they have one ) are different. 45Dr. SUGANTHINI. C, SCOPE, VIT Elimination of Left-Factoring But, if we re-write the grammar as follows A → A’ A’ → 1 | 2 so, we can immediately expand A to A’ 46Dr. SUGANTHINI. C, SCOPE, VIT 47Dr. SUGANTHINI. C, SCOPE, VIT Algorithm For each non-terminal A with two or more alternatives (production rules) with a common non-empty prefix, let say A → 1 | ... | n | 1 | ... | m convert it into A → A’ | 1 | ... | m A’ → 1 | ... | n Left-Factoring 48Dr. SUGANTHINI. C, SCOPE, VIT S → i E t S | i E t S e S | a E → b Example 1 49 S → i E t S S’ | a S’ → e S |  E → b  Dr. SUGANTHINI. C, SCOPE, VIT A → ad | a | ab | abc | b  A → aA’ | b A’ → d |  | b | bc  A → aA’ | b A’ → d |  | bA’’ A’’ →  | c Example 2 50Dr. SUGANTHINI. C, SCOPE, VIT Example 2 A → ad | a | ab | abc | b  A → aA’ | b A’ → d |  | b | bc  A → aA’ | b A’ → d |  | bA’’ A’’ →  | c 51Dr. SUGANTHINI. C, SCOPE, VIT A → abB | aB | cdg | cdeB | cdfB  A → aA’ | cdg | cdeB | cdfB A’ → bB | B  A → aA’ | cdA’’ A’ → bB | B A’’ → g | eB | fB Example 3 52Dr. SUGANTHINI. C, SCOPE, VIT Parsing Technique We categorize the parsers into two groups: 1. Top-Down Parsing ◦ the parse tree is created top to bottom, starting from the root. 2. Bottom-Up Parsing ◦ the parse is created bottom to top; starting from the leaves Both top-down and bottom-up parsers scan the input from left to right (one symbol at a time). Efficient top-down and bottom-up parsers can be implemented only for sub- classes of context-free grammars. ◦ LL for top-down parsing ◦ LR for bottom-up parsing 53Dr. SUGANTHINI. C, SCOPE, VIT Top Down Parsing ❑Recursive-Descent Parsing ❑Non-Recursive Predictive Parsing 54Dr. SUGANTHINI. C, SCOPE, VIT Bottom Down Parsing ❑Reduction ❑Handle Pruning ❑Shift-Reduce Parsing ❑Operator Precedence ❑LR Parser ❑SLR (Simple LR) ❑CLR (Canonical LR) ❑LALR (Lookahead LR) 55Dr. SUGANTHINI. C, SCOPE, VIT Top Down Parsing ❑Recursive-Descent Parsing ❑Non-Recursive Predictive Parsing 56Dr. SUGANTHINI. C, SCOPE, VIT Top Down Parser A Top-down parser tries to create a parse tree from the root towards the leafs scanning input from left to right It can be also viewed as finding a leftmost derivation for an input string Example: id+id*id Dr. SUGANTHINI. C, SCOPE, VIT Top-Down Parsing 58Dr. SUGANTHINI. C, SCOPE, VIT Recursive-Descent Parsing 59Dr. SUGANTHINI. C, SCOPE, VIT Recursive-Descent Parsing 60Dr. SUGANTHINI. C, SCOPE, VIT Recursive-Descent Parsing 61Dr. SUGANTHINI. C, SCOPE, VIT Non-Recursive Predictive Parsing 62Dr. SUGANTHINI. C, SCOPE, VIT Non-Recursive Predictive Parsing LL(1) Grammar ❑Elimination of Left Recursion / Left Factoring ❑FIRST and FOLLOW ❑Predictive parsing table ❑Stack Implementation 63Dr. SUGANTHINI. C, SCOPE, VIT LL(1) Grammar Predictive Parser, i.e recursive-descent parsers without backtracking is constructed for a class of grammar called LL(1) ❑L – Leftmost derivation ❑L – scans the input from left to right ❑1 – one input symbol of lookahead at each step to make parsing action 64Dr. SUGANTHINI. C, SCOPE, VIT Elimination of Left Recursion E → E+T | T T → T*F | F F → (E) F → id E → T E’ E’ → +T E’ |  T → F T’ T’ → *F T’ |  F → (E) F → id  65 Unambiguous Expression Grammar : Dr. SUGANTHINI. C, SCOPE, VIT FIRST and FOLLOW FIRST(X): Rules: 1. X is a Terminal, FIRST (X) = { X } 2. X is a Non-terminal, X → Y1, Y2, Y3 . . . . Yk , K ≥ 1, FIRST(X) = FIRST(Y1) 3. X → ε is a production, FIRST(X) = { ε } 66Dr. SUGANTHINI. C, SCOPE, VIT FIRST(x): 1 ) E → T E’ FIRST ( E) = FIRST (T) 2) E’ → +T E’ |  E’ → +T E’ E’ →  FIRST(E’) = + FIRST (E’) =  67Dr. SUGANTHINI. C, SCOPE, VIT 3)T → F T’ FIRST(T) = FIRST(F) 4)T’ → *F T’ |  T’ → *F T’ T’ →  FIRST(T’) = * FIRST(T’) =  68 FIRST(x): Dr. SUGANTHINI. C, SCOPE, VIT 69 5) F → (E) FIRST(E) = ( 6) F → id FIRST(E) = id FIRST(x): Dr. SUGANTHINI. C, SCOPE, VIT FIRST (X) 70 Non- terminal FIRST E ( , id E’ + , ε T ( , id T’ * , ε F ( , id Dr. SUGANTHINI. C, SCOPE, VIT FIRST and FOLLOW FOLLOW(X): Rules: 1. S is a Start Symbol, FOLLOW(S) = $ 2. If a production A → α B β , FOLLOW(B) = FIRST(β) – ε 3. If a production A → α B or A → α B β i.e, FIRST(β) = ε FOLLOW (B) = FOLLOW(A) 71Dr. SUGANTHINI. C, SCOPE, VIT FOLLOW(X) 1) E → T E’ FOLLOW(T) = FIRST(E’)-ε = + , ε – ε = + FOLLOW(T) = FOLLOW(E) FOLLOW(T) = + , FOLLOW(E) 72Dr. SUGANTHINI. C, SCOPE, VIT FOLLOW(X) 1) E → T E’ FOLLOW(E’) = FOLLOW(E) FOLLOW(E’) = FOLLOW(E) 73Dr. SUGANTHINI. C, SCOPE, VIT FOLLOW(X) 2) E’ → +T E’ |  FOLLOW(T) = FIRST(E’)-ε = + , ε – ε = + FOLLOW(T) = FOLLOW(E’) FOLLOW(T) = + , FOLLOW(E’) 74Dr. SUGANTHINI. C, SCOPE, VIT FOLLOW(X) 2) E’ → +T E’ |  FOLLOW(E’) = FOLLOW(E’) FOLLOW(E’) = FOLLOW(E’) 75Dr. SUGANTHINI. C, SCOPE, VIT FOLLOW(X) 3) T → F T’ FOLLOW(F) = FIRST(T’)-ε = * , ε – ε = * FOLLOW(F) = FOLLOW(T) FOLLOW(F) = * , FOLLOW(T) 76Dr. SUGANTHINI. C, SCOPE, VIT FOLLOW(X) 3) T → F T’ FOLLOW(T’) = FOLLOW(T) FOLLOW(T’) = FOLLOW(T) 77Dr. SUGANTHINI. C, SCOPE, VIT FOLLOW(X) 4) T’ → *F T’ |  FOLLOW(F) = FIRST(T’)-ε = * , ε – ε = * FOLLOW(F) = FOLLOW(T’) FOLLOW(F) = * , FOLLOW(T’) 78Dr. SUGANTHINI. C, SCOPE, VIT FOLLOW(X) 4) T’ → *F T’ |  FOLLOW(T’) = FOLLOW(T’) FOLLOW(T’) = FOLLOW(T’) 79Dr. SUGANTHINI. C, SCOPE, VIT FOLLOW(X) 5 ) F → (E) FOLLOW(E) = FIRST( ‘)’ ) = ) FOLLOW(E) = $ FOLLOW(E) = { ) , $ } 80Dr. SUGANTHINI. C, SCOPE, VIT FOLLOW(X) 6) F → id 81Dr. SUGANTHINI. C, SCOPE, VIT FOLLOW Non-terminal FOLLOW E ) , $ E’ FOLL(E’) = FOLL(E) FOLL(E’) = FOLL(E’) T FOLL(T) = + , FOLL(E) FOLL(T) = +, FOLL(E’) T’ FOLL(T’) = FOLL(T) FOLL(T’) = FOLL(T’) F FOLL(F) = * , FOLL(T) FOLL(F) = * , FOLL(T’) 82Dr. SUGANTHINI. C, SCOPE, VIT FOLLOW Non- terminal FOLLOW FOLLOW E ) , $ ) , $ E’ FOLLOW(E) , FOLLOW(E’) ) , $ T + , FOLLOW(E) , FOLLOW(E’) +, ) , $ T’ FOLLOW(T), FOLLOW(T’) +, ) , $ F * , FOLLOW(T), FOLLOW(T’) * , +, ) , $ 83Dr. SUGANTHINI. C, SCOPE, VIT FIRST and FOLLOW Non- terminal FIRST FOLLOW E ( , id ) , $ E’ + , ε ) , $ T ( , id +, ) , $ T’ * , ε +, ) , $ F ( , id * , +, ) , $ 84Dr. SUGANTHINI. C, SCOPE, VIT 85 Non-Recursive Predictive Parsing Dr. SUGANTHINI. C, SCOPE, VIT Predicting parsing Table 86Dr. SUGANTHINI. C, SCOPE, VIT Stack Implementation 87Dr. SUGANTHINI. C, SCOPE, VIT Stack Implementation 88Dr. SUGANTHINI. C, SCOPE, VIT Table-driven Predictive Parsing Stack Input Action $E id + id * id $ push E → TE’ $E’T id + id * id $ push T → FT’ $E’T’F id + id * id $ push F → id $E’T’id id + id * id $ pop (match id) $E’T’ + id * id $ push T’ → ε $E’ + id * id $ push E’ → +TE’ $E’T+ + id * id $ pop (match +) $E’T id * id $ push T → FT’ 89Dr. SUGANTHINI. C, SCOPE, VIT Table-driven Predictive Parsing Stack Input Action $E’T’F id * id $ push F → id $E’T’id id * id $ pop (match id) $E’T’ * id$ push T’ → *FT’ $E’T’F* *id$ pop (match *) $E’T’F id$ push F → id $E’T’id id$ pop (match id) $E’T’ $ push T’ → ε $E’ $ push E’ → ε $ $ Accept 90Dr. SUGANTHINI. C, SCOPE, VIT Table-driven Predictive Parsing 91Dr. SUGANTHINI. C, SCOPE, VIT Error Recovery in Predictive Parsing Error is detected in predictive parsing, M[A,a] is error ▪Panic mode ▪Phrase-level recovery 92Dr. SUGANTHINI. C, SCOPE, VIT Panic mode ▪Skipping symbols on the input until a token in a selected set of synchronizing tokens appears. ▪FOLLOW(A) ▪The synchronizing set for nonterminal A ▪Eg: if semicolons terminate statements as in C ▪FIRST(A) ▪Add to the synchronizing set for nonterminal A ▪NT produces the empty string ▪Terminal cannot be matched, pop the terminal 93Dr. SUGANTHINI. C, SCOPE, VIT Predictive Parsing Table 94Dr. SUGANTHINI. C, SCOPE, VIT Parsing and Error Recovery 95Dr. SUGANTHINI. C, SCOPE, VIT Phrase-level recovery ▪It is implemented by filling in the blank entries in the predictive parsing table with pointers to error routines. ▪These routines may change, insert, or delete symbols on the input and issue appropriate error messages. 96Dr. SUGANTHINI. C, SCOPE, VIT Example 2 Dangling Else-Statement: S → iEtS | iEtSeS | a E → b Input String: ibtibtaea$ 97Dr. SUGANTHINI. C, SCOPE, VIT Example 3 S → (L) | a L → L , S | S Input String: (a,(a,a))$ 98Dr. SUGANTHINI. C, SCOPE, VIT Example 4 S → a | ↑ | (T) T → T , S | S Input String: (a,(a,↑))$ 99Dr. SUGANTHINI. C, SCOPE, VIT Thank You 100Dr. SUGANTHINI. C, SCOPE, VIT","libVersion":"0.5.0","langs":""}