{"path":"sem5/AI/pdf/wisc_pl.pdf","text":"slide 1 Propositional Logic Reading: Chapter 7.1, 7.3 – 7.5 [Based on slides from Jerry Zhu, Louis Oliphant and Andrew Moore] slide 3 Logic • If the rules of the world are presented formally, then a decision maker can use logical reasoning to make rational decisions • Several types of logic:  Propositional Logic (Boolean logic)‏  First-Order Logic (aka first-order predicate calculus)‏  Non-Monotonic Logic  Markov Logic • A logic includes:  syntax: what is a correctly-formed sentence?  semantics: what is the meaning of a sentence?  Inference procedure (reasoning, entailment): what sentence logically follows given knowledge? slide 4 Propositional Logic • A symbol in PL is a symbolic variable whose value must be either True or False, and which stands for a natural language statement that could be either true or false  A = “Smith has chest pain”  B = “Smith is depressed”  C = “It is raining” slide 5 P  ((True  R)  Q))  S) well formed (“wff” or “sentence”) P  Q)   S) not well formed Propositional Logic Syntax Sentence  AtomicSentence | ComplexSentence AtomicSentence  True | False | Symbol Symbol  P | Q | R | . . . ComplexSentence   Sentence | ( Sentence  Sentence )‏ | ( Sentence  Sentence )‏ | ( Sentence  Sentence )‏ | ( Sentence  Sentence )‏ BNF (Backus-Naur Form) grammar in propositional logic slide 6 P  ((True  R)  Q))  S)‏ Means True Means‏“Not”Means‏“Or”‏--‏disjunctionMeans‏“And”‏--‏conjunctionMeans‏“iff”‏--‏biconditional Means‏“if-then”‏‏ implication () control the order of operations Propositional symbols must be specified Propositional Logic Syntax slide 7 Propositional Logic Syntax • Precedence (from highest to lowest):      • If the order is clear, you can leave off parentheses P  True  RQ  S ok P  Q  S not ok slide 8 Semantics • An interpretation is a complete True / False assignment to all propositional symbols  Example symbols: P means “It is hot”, Q means “It is humid”, R means “It is raining”  There are 8 interpretations (TTT, ..., FFF)‏ • The semantics (meaning) of a sentence is the set of interpretations in which the sentence evaluates to True • Example: the semantics of the sentence P  Q is the set of 6 interpretations:  P=True, Q=True, R=True or False  P=True, Q=False, R=True or False  P=False, Q=True, R=True or False • A model of a set of sentences is an interpretation in which all the sentences are true slide 9 Evaluating a Sentence under an Interpretation • Calculated using the definitions of all the connectives, recursively • Pay attention to   “5 is even implies 6 is odd” is True!  If P is False, regardless of Q, PQ is True  No causality needed: “5 is odd implies the Sun is a star” is True slide 10 Understanding “” • This is an operator. Although we call it “implies” or “implication,” do not try to understand its semantic form from the name. We could have called it “foo” instead and still defined its semantics the same way. • A  B “means” A is sufficient but not necessary to make B true • Example:  Let A be “has a cold” and B be “drink water”  A  B can be interpreted as “should drink water” when “has a cold.”  However, you can drink water even when you do not have a cold. Thus A  B is still true when A is not true. slide 11 Example P  Q  R  Q slide 12 Example P  Q  R  Q P Q R ~P Q^R ~PvQ^R ~PvQ^R->Q 0 0 0 1 0 1 0 0 0 1 1 0 1 0 0 1 0 1 0 1 1 0 1 1 1 1 1 1 1 0 0 0 0 0 1 1 0 1 0 0 0 1 1 1 0 0 0 0 1 1 1 1 0 1 1 1 Satisfiable: a sentence that is true under some interpretations Deciding satisfiability of a sentence is NP-complete‏ slide 13 Example (P  R  Q)  P  R   Q slide 14 Example (P  R  Q)  P  R   Q Unsatisfiable: a sentence that is false under all interpretations Also called inconsistent or a contradiction P Q R ~Q R^~Q P^R^~Q P^R P^R->Q final 0 0 0 1 0 0 0 1 0 0 0 1 1 1 0 0 1 0 0 1 0 0 0 0 0 1 0 0 1 1 0 0 0 0 1 0 1 0 0 1 0 0 0 1 0 1 0 1 1 1 1 1 0 0 1 1 0 0 0 0 0 1 0 1 1 1 0 0 0 1 1 0 slide 15 Example (P  Q)  P   Q slide 16 Example (P  Q)  P   Q Valid: a sentence that is true under all interpretations Also called a tautology P Q R ~Q P->Q P^~Q (P->Q)vP^~Q 0 0 0 1 1 0 1 0 0 1 1 1 0 1 0 1 0 0 1 0 1 0 1 1 0 1 0 1 1 0 0 1 0 1 1 1 0 1 1 0 1 1 1 1 0 0 1 0 1 1 1 1 0 1 0 1 slide 17 Knowledge Base (KB) • A knowledge base, KB, is a set of sentences. Example KB:  TomGivingLecture  (TodayIsTuesday  TodayIsThursday)‏   TomGivingLecture • It is equivalent to a single long sentence: the conjunction of all sentences  ( TomGivingLecture  (TodayIsTuesday  TodayIsThursday) )   TomGivingLecture • A model of a KB is an interpretation in which all sentences in KB are true slide 18 Entailment • Entailment is the relation of a sentence  logically following from other sentences  (e.g., KB)  |=  •  |=  if and only if, in every interpretation in which  is true,  is also true; whenever  is true, so is ; all models of  and also models of  • Deduction theorem:  |=  if and only if    is valid (always true)‏ • Proof by contradiction (refutation, reductio ad absurdum):  |=  if and only if    is unsatisfiable • There are 2n interpretations to check, if KB has n symbols slide 19 All interpretations Entailment • Entailment is the relation of a sentence  logically following from other sentences  (e.g., the KB)  |=  •  |=  if and only if, in every interpretation in which  is true,  is also true  is true  is true slide 20 Deductive Inference • Let’s say you write an algorithm which, according to you, proves whether a sentence  is entailed by  • The thing your algorithm does is called deductive inference • We don’t trust your inference algorithm (yet), so we write things your algorithm finds as  |-  • It reads “ is derived from  by your algorithm” • What properties should your algorithm have?  Soundness: the inference algorithm only derives entailed sentences. That is, if  |-  then  |=   Completeness: all entailment can be inferred. That is, if  |=  then  |-  slide 21 Soundness and Completeness • Soundness says that any wff that follows deductively from a set of axioms, KB, is valid (i.e., true in all models) • Completeness says that all valid sentences (i.e., true in all models of KB), can be proved from KB and hence are theorems slide 22 22 Method 1: Inference by Enumeration LET: KB = A  C, B  C α = A  B QUERY: KB ╞ α ? A B C false false false false false true false true false false true true true false false true false true true true false true true true NOTE: The computer doesn't know the meaning of the proposition symbols So, all logically distinct cases must be checked to prove that a sentence can be derived from KB Also called Model Checking or Truth Table Enumeration slide 23 23 Inference by Enumeration LET: KB = A  C, B  C α = A  B QUERY: KB ╞ α ? AC B C KB false true false true false false false true false true true true true true true true false false true true true true true true Rows where all of sentences in KB are true are the models of KB A B C false false false false false true false true false false true true true false false true false true true true false true true true slide 24 24 Inference by Enumeration LET: KB = A  C, B  C α = A  B QUERY: KB ╞ α ? AC B C KB false true false true false false false true false true true true true true true true false false true true true true true true α is entailed by KB if all models of KB are models of α, i.e., all rows where KB is true, α is also true A B C false false false false false true false true false false true true true false false true false true true true false true true true AB false false true true true true true true YES! In other words: KB α is valid KBα true true true true true true true true slide 25 Inference by Enumeration • Using inference by enumeration to build a complete truth table in order to determine if a sentence is entailed by KB is a complete inference algorithm for Propositional Logic • But very slow: takes exponential time slide 26 Method 2: Natural Deduction using Sound Inference Rules Goal: Define a more efficient algorithm than enumeration that uses a set of inference rules to incrementally deduce new sentences that are true given the initial set of sentences in KB plus uses all logical equivalences slide 27 Logical Equivalences You can use these equivalences to derive or modify sentences slide 28 Sound Inference Rules • Modus Ponens (Latin: mode that affirms)‏ • And-Elimination          Note: Prove that an inference rule is sound by using a truth table P Q P PQ P  (PQ) Q (P  (PQ))  Q T T T T T T T T F T F F F T F T F T F T T F F F T F F T slide 29 29 Some Sound Inference Rules • Implication-Elimination, IE (Modus Ponens, MP) α  β, α β  And-Elimination, AE  And-Introduction, AI  Or-Introduction, OI α1  α2  …  αn αi α1, α2, … , αn α1  α2  …  αn αi α1  α2  …  αn  Double-Negation Elimination, DNE  α α slide 30 Inference Rules • Each inference rule formalizes the idea that “A infers B” (A |- B) in terms of “logically follows” (A |= B) • Doesn’t say anything about deducibility – just says for each interpretation that makes A true, that interpretation also makes B true slide 31 Question What’s the difference between  (logical equivalence) |= (entailment) |- (derived from) slide 32 Natural Deduction = Constructing a Proof • A Proof is a sequence of inference steps that leads from  (i.e., KB) to  • This is a search problem! KB: 1. (P  Q)  R 2. (S  T)  Q 3. S 4. T 5. P : R slide 33 Proof by Natural Deduction 1. S Premise (in KB) 2. T Premise 3. S  T Conjunction(1, 2) (And-Introduction) 4. (S  T)  Q Premise 5. Q Modus Ponens(3, 4) 6. P Premise 7. P  Q Conjunction(5, 6) 8. (P  Q)  R Premise 9. R Modus Ponens(7, 8) Last line is query sentence  slide 34 Monotonicity Property • Note that natural deduction relies on the monotonicity property of Propositional Logic: • Deriving a new sentence and adding it to KB does NOT affect what can be entailed from the original KB • Hence we can incrementally add new true sentences that are derived in any order • Once something is proved true, it will remain true slide 37 Method 3: Resolution • Your algorithm can use all the logical equivalences, Modus Ponens, And-Elimination to derive new sentences • Resolution rule: a single inference rule  Sound: only derives entailed sentences  Complete: can derive any entailed sentence • Resolution is only refutation complete: if KB |= , then KB    |- False.  But the sentences need to be preprocessed into a special form  But all sentences can be converted into this form slide 38 Resolution • Take any two clauses where one contains some symbol, and the other contains its complement (negative)‏ P  Q  R Q  S  T • Merge (resolve) them, throw away the symbol and its complement P  R  S  T • If two clauses resolve and there’s no symbol left, you have derived the empty clause (False), so KB |=  • If no new clauses can be added, KB does not entail  slide 39 Resolution Rule of Inference • Show KB |=  by proving that KB   is unsatsifiable, i.e., deducing False from KB   • Resolution Rule of Inference • Examples A B B,A  FEDCB FEA D,CBA   γα γβ β,α   called‏“unit‏resolution” slide 40 Resolution Refutation Algorithm 1. Add negation of query to KB 2. Pick 2 sentences that haven’t been used before and can be used with the Resolution Rule of inference 3. If none, halt and answer that the query is NOT entailed by KB 4. Compute resolvent and add it to KB 5. If False in KB  Then halt and answer that the query IS entailed by KB  Else Goto 2 slide 41 Conjunctive Normal Form (CNF)‏ A  B  C)  (B  A)  C  A)‏ – Replace all  using iff/biconditional elimination –     (  )  (  ) – Replace all  using implication elimination –        – Move all negations inward using – double-negation elimination – ()   - de Morgan's rule – (  )     – (  )     – Apply distributivity of  over  –   (  )  (  )  (  ) + 1 more slide 42 Convert Sentence into CNF A  (B  C) starting sentence (A  (B  C))  ((B  C)  A ) iff/biconditional elimination A  B  C)  ((B  C)  A ) implication elimination A  B  C)  ((B  C)  A ) move negations inward A  B  C)  (B  A)  C  A) distribute  over  called‏a‏“clause” slide 43 Resolution Steps • Given KB and  (query) • Add   to KB, and convert all sentences to CNF • Show this leads to False (aka “empty clause”). Proof by contradiction‏ • Example KB:  A  (B  C)‏  A • Example query: B slide 44 Resolution Preprocessing • Add   to KB, and convert to CNF: a1: A  B  C a2: B  A a3: C  A b: A c: B • Want to reach goal: False (empty clause) slide 45 Resolution Example a1: A  B  C a2: B  A a3: C  A b: A c: B slide 46 Resolution Example a1: A  B  C a2: B  A a3: C  A b: A c: B Step 1: resolve a2, c: A Step 2: resolve above and b: empty slide 47 Example • Given:  P  Q  P  R  Q  R • Prove: R slide 48 Example • Given:  (P  Q)  Q  (P  P)  R  (R  S)  (S  Q) • Prove: R slide 49 Example • Given:  P  P • Prove: R slide 50 Efficiency of the Resolution Algorithm • Run time can be exponential in the worst case  Often much faster • Factoring: if a new clause contains duplicates of the same symbol, delete the duplicates P  R  P  T  P  R  T • If a clause contains a symbol and its complement, the clause is a tautology and is useless; it can be thrown away a1: A  B  C)‏ a2: (B  A)‏ Resolvent of a1 and a2 is: B  C  B Which is valid, so throw it away slide 51 Method 4: Chaining with Horn Clauses • Resolution is more powerful than we need for many practical situations • A weaker form: Horn clauses  Disjunction of literals with at most one positive R  P  Q no R   P  Q yes  KB = conjunction of Horn clauses  What’s the big deal? R   P  Q  R  P)  Q  ? slide 52 Horn Clauses R   P  Q  R  P)  Q  (R  P)  Q Every rule in KB is in this form P (special case, no negative literals): fact R   P (special case, no positive literal): goal clause • The big deal:  KB easy for humans to read  Natural forward chaining and backward chaining algorithms; proof easy for humans to read  Can decide entailment with Horn clauses in time linear with KB size • But …  Can only ask atomic queries slide 53 Horn Clauses • Only 1 rule of inference needed • Generalized Modus Ponens: P, Q, (P  Q)  R R slide 54 Forward Chaining • “Apply” any rule whose premises are satisfied in the KB • Add its conclusion to the KB until query is derived KB: query: Q • Forward chaining with Horn clause KB is complete slide 55 Forward Chaining 1. P  Q 2. L  M  P 3. B  L  M 4. A  P  L 5. A  B  L 6. A 7. B 8. L GMP(5,6,7) 9. M GMP(3,7,8) 10. P GMP(2,8,9) 11. Q GMP(1,10) slide 65 Backward Chaining • Forward chaining problem: can generate a lot of irrelevant conclusions  Search forward, start state = KB, goal test = state contains query • Backward chaining  Work backwards from goal to premises  Find all implications of the form (…)  query  Prove all the premises of one of these implications  Avoid loops: check if new subgoal is already on the goal stack  Avoid repeated work: check if new subgoal 1. Has already been proved true, or 2. Has already failed slide 66 Backward Chaining 1. P  Q 2. L  M  P 3. B  L  M 4. A  P  L 5. A  B  L 6. A 7. B 8. Q Goal 9. P Subgoal(1,8) 10. L  M Subgoal(2,9) 11. L Subgoal(10) 12. A  B Subgoal(5,11) 13. A True(6) 14. B True(7) 15. L True(5,13,14) 16. M True(14,15) 17. P True(15,16) 18. Q True(1,17) slide 67 Backward Chaining P  Q L  M  P B  L  M A  P  L A  B  L A B slide 68 Backward Chaining P  Q L  M  P B  L  M A  P  L A  B  L A B slide 69 Backward Chaining P  Q L  M  P B  L  M A  P  L A  B  L A B slide 70 Backward Chaining P  Q L  M  P B  L  M A  P  L A  B  L A B slide 71 Backward Chaining P  Q L  M  P B  L  M A  P  L A  B  L A B slide 72 Backward Chaining P  Q L  M  P B  L  M A  P  L A  B  L A B slide 73 Backward Chaining P  Q L  M  P B  L  M A  P  L A  B  L A B slide 74 Backward Chaining P  Q L  M  P B  L  M A  P  L A  B  L A B slide 75 Backward Chaining P  Q L  M  P B  L  M A  P  L A  B  L A B slide 76 Backward Chaining P  Q L  M  P B  L  M A  P  L A  B  L A B slide 77 Forward vs. Backward Chaining • Forward chaining is data-driven  May perform lots of work irrelevant to the goal • Backward chaining is goal-driven  Appropriate for problem solving  Time complexity can be much less than linear in size of KB • Some form of bi-directional search may be even better slide 78 Problems with Propositional Logic • Consider the game “minesweeper” on a 10x10 field with only one land mine • How do you express the knowledge, with Propositional Logic, that the squares adjacent to the land mine will display the number 1? slide 79 Problems with Propositional Logic • Consider the game “minesweeper” on a 10x10 field with only one land mine • How do you express the knowledge, with Propositional Logic, that the squares adjacent to the land mine will display the number 1? • Intuitively with a rule like Landmine(x,y)  Number1(Neighbors(x,y))‏ but Propositional Logic cannot do this slide 80 Problems with Propositional Logic • Propositional Logic has to say, e.g. for cell (3,4):  Landmine_3_4  Number1_2_3  Landmine_3_4  Number1_2_4  Landmine_3_4  Number1_2_5  Landmine_3_4  Number1_3_3  Landmine_3_4  Number1_3_5  Landmine_3_4  Number1_4_3  Landmine_3_4  Number1_4_4  Landmine_3_4  Number1_4_5  And similarly for each of Landmine_1_1, Landmine_1_2, Landmine_1_3, …, Landmine_10_10 • Difficult to express large domains concisely • Don’t have objects and relations • First-Order Logic is a powerful upgrade slide 82 What You Should Know • A lot of terms • Use truth tables (inference by enumeration) • Natural deduction proofs • Conjuctive Normal Form (CNF) • Resolution Refutation algorithm and proofs • Horn clauses • Forward chaining algorithm • Backward chaining algorithm","libVersion":"0.5.0","langs":""}