{"path":"sem5/DBMS/pdfs/Module 3.1.pdf","text":"Module 3 Module:3 Relational Database Design Database Design – Schema Refinement - Guidelines for Relational Schema – Functional dependencies - Axioms on Functional Dependencies- Normalization: First, Second and Third Normal Forms - Boyce Codd Normal Form, Multi-valued dependency and Fourth Normal form - Join dependency and Fifth Normal form  Reference :  R. Elmasri & S. B. Navathe, Fundamentals of Database Systems, Addison Wesley, 7th Edition, 2016  A. Silberschatz, H. F. Korth & S. Sudarshan, Database System Concepts, McGraw Hill,7th Edition 2019.  A functional dependency is a relationship between two sets of attributes in a relational database.  if a set of attributes X can uniquely determine another set of attributes Y, We say that Y is functionally dependent on X. This is denoted as X → Y.  Example: consider a Student table with the following attributes Student( StudentID, StudentName, Course, Instructor) If each course is taught by only one instructor, then the attribute Course can determine the attribute Instructor. Course→Instructor This means if we know the course, we can determine the instructor uniquely. Slide 1- 2 What is Functional Dependency in DBMS? Functional Dependency Slide 1- 3 In any relation, a functional dependency α → β holds if- Two tuples having same value of attribute α also have same value for attribute β. Mathematically, If α and β are the two sets of attributes in a relational table R where, α R⊆ β R⊆ Then, for a functional dependency to exist from α to β, If t1[α] = t2[α], then t1[β] = t2[β] α β t1[α] t1[β] t2[α] t2[β] ……. ……. fd : α → β Hold in FD Slide 1- 4 In the context of functional dependencies (FDs) in relational database theory, the terms \"holds\" and \"satisfies\" have specific meanings related to how a relation (i.e., a table) conforms to a given functional dependency. \"Holds\" A functional dependency X → Y holds in a relation R if for every pair of tuples t1 and t2 in R, whenever: t1[X] = t2[X] it follows that: t1[Y] = t2[Y] In simpler terms: The FD is always true for the data in that relation. Example: Consider a relation Students(StudentID, Name, Major), and suppose the data is: Here, the FD StudentID → Name holds, because whenever StudentID is the same (1001), the Name is also the same (Alice). StudentID Name Major 1001 Alice CS 1002 Bob Math 1001 Alice CS Satisies in FD Slide 1- 5 A relation R satisfies a set of functional dependencies F if all FDs in F hold in R. \"satisfies\" as applying to a set of FDs  while \"holds\" applies to a single FD. Example: Let F = { StudentID → Name, StudentID → Major } The relation Students satisfies F if both of those FDs hold in the data. FD holds :A specific FD is true for all rows in a relation Relation satisfies FD(s): A relation satisfies a set of FDs if all of them hold in it Importance of Functional Dependencies in Database Design  Functional dependencies are essential for database normalization  To reduce redundancy and improve data integrity in databases.  Prevent anomalies during database updation.  Help in identifying the correct schema design by ensuring that each attribute is stored in the appropriate table. Types of Functional Dependencies There are 2 types of functional dependencies in DBMS. 1. Trivial Functional Dependency A functional dependency X → Y is trivial if Y is a subset of X. Example: StudentID, Course→Course 2. Non-Trivial Functional Dependency A functional dependency X → Y is non-trivial if Y is not a subset of X. Example: Course →Instructorid, course Slide 1- 6 Armstrong’s Axioms? Armstrong’s Axioms are a set of rules used to infer all the functional dependencies on a relational database. They are: Reflexivity: If Y is a subset of X, then X → Y. Augmentation: If XZ → YZ, then XZ → YZ for any Z. Transitivity: If X → Y and Y → Z, then X → Z. Additional derived rules include: Union: If X → Y and X → Z, then X → YZ. Decomposition: If X → YZ, then X → Y and X → Z. Pseudo Transitivity: If X → Y and YZ → W, then XZ→ W. Slide 1- 7 How to Identify Functional Dependencies? To identify functional dependencies, you can: Analyze Data: Look for patterns and relationships in sample data. Understand Business Rules: Comprehend the business rules and constraints governing the data. Consult Documentation: Use ER diagrams and schema definitions to identify potential dependencies. Use SQL Queries: Write queries to check if certain attributes consistently determine others. Slide 1- 8 Rules for Functional Dependency  A functional dependency X → Y will always hold if all the values of X are unique (different) irrespective of the values of Y.  Example- Consider the following table Slide 1- 9 A B C D E 5 4 3 2 2 8 5 3 2 1 1 9 3 3 5 4 7 3 3 8 The following functional dependencies will always hold since all the values of attribute ‘A’ are unique. A  B A+ =(A,B,C,D,E)→ A  BC→ A  CD→ A  BCD→ A  DE→ A  BCDE→ In general, we can say following functional dependency will always hold A   Any combination of attributes → A, B, C, D, E Similar will be the case for attributes B and E. Rules for Functional Dependency  A functional dependency X → Y will always hold if all the values of Y are same irrespective of the values of X.  Example- Consider the following table Slide 1- 10 The following functional dependencies will always hold since all the values of attribute ‘C’ are same- A → C AB → C ABDE → C DE → C AE → C In general, we can say following functional dependency will always hold true. A B C D E 8 5 3 2 2 8 5 3 2 1 1 9 3 3 5 4 7 3 3 8 Rules for Functional Dependency Slide 1- 11  In general, a functional dependency α   β always holds, → If either all values of α are unique or if all values of β are same or both   NOTE: 1.For a functional dependency X  Y to hold, if two tuples → in the table agree on the value of attribute X, then they must also agree on the value of attribute Y. 2. For a functional dependency X  Y, violation will occur → only when for two or more same values of X, the corresponding Y values are different.  Equivalence of Two Sets of Functional Dependencies Slide 1- 12 Two different sets of functional dependencies for a given relation may or may not be equivalent. If F and G are the two sets of functional dependencies, then following 3 cases are possible- Case-01: F covers G (F G)⊇ Case-02: G covers F (G F)⊇ Case-03: Both F and G cover each other (F = G)  Equivalence of Two Sets of Functional Dependencies Slide 1- 13 Case-01: Determining Whether F Covers G- Following steps are followed to determine whether F covers G or not-  Step-01:  Take the functional dependencies of set G into consideration. For each functional dependency X+  Y, find the → closure of X using the functional dependencies of set G.  Step-02:  Take the functional dependencies of set G into consideration. For each functional dependency X  Y, find the → closure of X using the functional dependencies of set F.  Step-03: Compare the results of Step-01 and Step-02. If the functional dependencies of set F has determined all those attributes that were determined by the functional dependencies of set G, then it means F covers G. Thus, we conclude F covers G (F ⊇ G) otherwise not.  Equivalence of Two Sets of Functional Dependencies Slide 1- 14 Case-02: Determining Whether G Covers F- Following steps are followed to determine whether G covers F or not- Step-01: Take the functional dependencies of set F into consideration. For each functional dependency X → Y, find the closure of X using the functional dependencies of set F. Step-02: Take the functional dependencies of set F into consideration. For each functional dependency X → Y, find the closure of X using the functional dependencies of set G. Step-03: Compare the results of Step-01 and Step-02. If the functional dependencies of set G has determined all those attributes that were determined by the functional dependencies of set F, then it means G covers F. Thus, we conclude G covers F (G F⊇ ) otherwise not.  Equivalence of Two Sets of Functional Dependencies Slide 1- 15 Case-02: Determining Whether G Covers F- Following steps are followed to determine whether G covers F or not- Step-01: Take the functional dependencies of set F into consideration. For each functional dependency X → Y, find the closure of X using the functional dependencies of set F. Step-02: Take the functional dependencies of set F into consideration. For each functional dependency X → Y, find the closure of X using the functional dependencies of set G. Step-03: Compare the results of Step-01 and Step-02. If the functional dependencies of set G has determined all those attributes that were determined by the functional dependencies of set F, then it means G covers F. Thus, we conclude G covers F (G F⊇ ) otherwise not.  Equivalence of Two Sets of Functional Dependencies Slide 1- 16 Case-03: Determining Whether Both F and G Cover Each Other If F covers G and G covers F, then both F and G cover each other. Thus, if both the above cases hold true, we conclude both F and G cover each other (F = G). Slide 1- 17 PRACTICE PROBLEM BASED ON EQUIVALENCE OF FUNCTIONAL DEPENDENCIES-   Problem-  A relation R (A , C , D , E , H) is having two functional dependencies sets F and G as shown-  Set F A  C → (AC ) D → E  AD→ E  H→ Set G- A  CD → E  AH →  Which of the following holds true? (A) G ⊇ F (B) F ⊇ G (C) F = G (D) All of the above Slide 1- 18 Solution- Determining whether F covers G- Step-01: (A) + = { A , C , D } // closure of left side of A → CD using set G (E)+ = { A , C , D , E , H } // closure of left side of E → AH using set G Step-02: (A)+ = { A , C , D } // closure of left side of A → CD using set F (E)+ = { A , C , D , E , H } // closure of left side of E → AH using set F Step-03: Comparing the results of Step-01 and Step-02, we find- Functional dependencies of set F can determine all the attributes which have been determined by the functional dependencies of set G. Thus, we conclude F covers G i.e. F G.⊇ Slide 1- 19 Determining whether G covers F- Step-01: (A) + = { A , C , D } // closure of left side of A → C using set F (AC)+ = { A , C , D } // closure of left side of AC → D using set F (E)+ = { A , C , D , E , H } // closure of left side of E → AD and E → H using set F Step-02: (A) + = { A , C , D } // closure of left side of A → C using set G (AC)+ = { A , C , D } // closure of left side of AC → D using set G (E)+ = { A , C , D , E , H } // closure of left side of E → AD and E → H using set G Step-03: Comparing the results of Step-01 and Step-02, we find- Functional dependencies of set G can determine all the attributes which have been determined by the functional dependencies of set F. Thus, we conclude G covers F i.e. G F.⊇ Slide 1- 20 Determining whether G covers F- Step-01: (A) + = { A , C , D } // closure of left side of A → C using set F (AC)+ = { A , C , D } // closure of left side of AC → D using set F (E)+ = { A , C , D , E , H } // closure of left side of E → AD and E → H using set F Step-02: (A) + = { A , C , D } // closure of left side of A → C using set G (AC)+ = { A , C , D } // closure of left side of AC → D using set G (E)+ = { A , C , D , E , H } // closure of left side of E → AD and E → H using set G Step-03: Comparing the results of Step-01 and Step-02, we find- Functional dependencies of set G can determine all the attributes which have been determined by the functional dependencies of set F. Thus, we conclude G covers F i.e. G F.⊇ Slide 1- 21 Determining whether both F and G cover each other- From Step-01, we conclude F covers G. From Step-02, we conclude G covers F. Thus, we conclude both F and G cover each other i.e. F = G. Thus, Option (D) is correct. Definition of Canonical Cover  A canonical cover is a simplified and reduced version of the given set of functional dependencies.  It is also called as Irreducible set. Characteristics-  Canonical cover is free from all the extraneous functional dependencies.  The closure of canonical cover is same as that of the given set of functional dependencies.  Canonical cover is not unique and may be more than one for a given set of functional dependencies. Need of Canonical Cover:  Working with the set containing extraneous functional dependencies increases the computation time.  Therefore, the given set is reduced by eliminating the useless functional dependencies.  This reduces the computation time and working with the irreducible set becomes easier. Steps To Find Canonical Cover Step-01: Write the given set of functional dependencies in such a way that each functional dependency contains exactly one attribute on its right side. Example- The functional dependency X → YZ will be written as- X → Y X → Z Step-02: Consider each functional dependency one by one from the set obtained in Step-01.  Determine whether it is essential or non-essential. To determine whether a functional dependency is essential or not, compute the closure of its left side-  Once by considering that the particular functional dependency is present in the set  Once by considering that the particular functional dependency is not present in the set Steps To Find Canonical Cover Then following two cases are possible- Case-01: Results Come Out to be Same- If results come out to be same, It means that the presence or absence of that functional dependency does not create any difference. Thus, it is non-essential. Eliminate that functional dependency from the set. NOTE  Eliminate the non-essential functional dependency from the set as soon as it is discovered. Do not consider it while checking the essentiality of other functional dependencies. Steps To Find Canonical Cover Case-02: Results Come Out to be Different- If results come out to be different, It means that the presence or absence of that functional dependency creates a difference. Thus, it is essential. Do not eliminate that functional dependency from the set. Mark that functional dependency as essential. Steps To Find Canonical Cover Step-03:  Consider the newly obtained set of functionaldependencies after performing Step-02.  Check if there is any functional dependency that contains more than one attribute on its left side. Then following two cases are possible: Case-01: No-  There exists no functional dependency containing more than one attribute on its left side.  In this case, the set obtained in Step-02 is the canonical cover. Case-02: Yes  There exists at least one functional dependency containing more than one attribute on its left side.  In this case, consider all such functional dependencies one by one.  Check if their left side can be reduced.  Problem- The following functional dependencies hold true for the relational scheme R ( W , X , Y , Z ) X  W→ WZ  Y→ Y  WXZ → Write the irreducible equivalent for this set of functional dependencies.  Solution-  Step-01:  Write all the functional dependencies such that each contains exactly one attribute on its right side- X  W→ WZ  X → WZ  Y→ Y  W→ Y  X→ Y  Z→   Slide 1- 28 Step-02:  Check the essentiality of each functional dependency one by one.  For X  W:→ Considering X  W, (X)→ + = { X , W } Ignoring X  W, (X)→ + = { X }  Now, Clearly, the two results are different. Thus, we conclude that X  W is essential and can not be → eliminated.  For WZ X:→  Considering WZ X, (WZ)→ + = { W , X , Y , Z } Ignoring WZ X, (WZ)→ + = { W , X , Y , Z } Now, Clearly, the two results are same. Thus, we conclude that WZ X is non-essential and can be → eliminated.  Eliminating WZ  X, our set of functional dependencies → reduces to- X  W→ WZ  Y→ Y  W→ Y  X→ Y  Z→ Now, we will consider this reduced set in further checks.   Slide 1- 29 For WZ → Y: Considering WZ → Y, (WZ)+ = { W , X , Y , Z } Ignoring WZ → Y, (WZ)+ = { W , Z } Now, Clearly, the two results are different. Thus, we conclude that WZ → Y is essential and can not be eliminated. For Y → W: Considering Y → W, (Y)+ = { W , X , Y , Z } Ignoring Y → W, (Y)+ = { W , X , Y , Z } Now, Clearly, the two results are same. Thus, we conclude that Y → W is non-essential and can be eliminated. Eliminating Y → W, our set of functional dependencies reduces to- X → W WZ → Y Y → X Y → Z Slide 1- 30 For Y X:→  Considering Y X, (Y)→ + = { W , X , Y , Z } Ignoring Y X, (Y)→ + = { Y , Z }  Now, Clearly, the two results are different. Thus, we conclude that Y X is essential and can not be → eliminated.  For Y Z:→  Considering Y Z, (Y)→ + = { W , X , Y , Z } Ignoring Y Z, (Y)→ + = { W , X , Y }  Now, Clearly, the two results are different. Thus, we conclude that Y Z is essential and can not be → eliminated.  From here, our essential functional dependencies are-   X  W→ WZ  Y→ Y  X→ Y  Z→ Slide 1- 31 Step-03: Consider the functional dependencies having more than one attribute on their left side. Check if their left side can be reduced. In our set, Only WZ → Y contains more than one attribute on its left side. Considering WZ → Y, (WZ)+ = { W , X , Y , Z } Now, Consider all the possible subsets of WZ. Check if the closure result of any subset matches to the closure result of WZ. (W)+ = { W } (Z)+ = { Z } Slide 1- 32 Clearly, None of the subsets have the same closure result same as that of the entire left side. Thus, we conclude that we can not write WZ → Y as W → Y or Z → Y. Thus, set of functional dependencies obtained in step-02 is the canonical cover. Finally, the canonical cover is- X → W WZ → Y Y → X Y → Z Decomposition of a Relation- Properties of Decomposition- The following two properties must be followed when decomposing a given relation- 1. Lossless decomposition- Lossless decomposition ensures- No information is lost from the original relation during decomposition. When the sub relations are joined back, the same relation is obtained that was decomposed. Every decomposition must always be lossless. Dependency preservation ensures- None of the functional dependencies that holds on the original relation are lost. The sub relations still hold or satisfy the functional dependencies of the original relation.   The process of breaking up or dividing a single relation into two or more sub relations is called as decomposition of a relation. Slide 1- 34 1. Lossless Join Decomposition- Consider there is a relation R which is decomposed into sub relations R 1 , R2 , …. , Rn. This decomposition is called lossless join decomposition when the join of the sub relations results in the same relation R that was decomposed. For lossless join decomposition, we always have- where ⋈ is a natural join operator  Example-  Consider the following relation R( A , B , C )-   R( A , B , C ) A B C 1 2 1 2 5 3 3 3 3 Slide 1- 35 Consider this relation is decomposed into two sub relations R 1( A , B ) and R 2( B , C )- The two sub relations are-     B C 2 1 5 3 3 3 B C 2 1 5 3 3 3 Now, let us check whether this decomposition is lossless or not. For lossless decomposition, we must have- R1 ⋈ R2 = R  Now, if we perform the natural join ( ⋈ ) of the sub relations R1 and R2 , we get- A B C 1 2 1 2 5 3 3 3 3 This relation is same as the original relation R. Thus, we conclude that the above decomposition is lossless join decomposition. R( A , B, C ) NOTE- Lossless join decomposition is also known as non- additive join decomposition. This is because the resultant relation after joining the sub relations is same as the decomposed relation. No extraneous tuples appear after joining of the sub- relations.   2. Lossy Join Decomposition- known as careless decomposition. Consider there is a relation R which is decomposed into sub relations R1 , R2 , …. , Rn. •This decomposition is called lossy join decomposition when the join of the sub relations does not result in the same relation R that was decomposed. •The natural join of the sub relations is always found to have some extraneous tuples. •For lossy join decomposition, we always have- where is a natural join operator⋈ R1 R⋈ 2 R⋈ 3 ……. R⋈ n R ⊃ A B C 1 2 1 2 5 3 3 3 3 Example- Consider the following relation R( A , B , C )-     R( A , B , C ) Consider this relation is decomposed into two sub relations as R1( A , C ) and R2( B , C )- A C 1 1 2 3 3 3 B C 2 1 5 3 3 3 Now, let us check whether this decomposition is lossy or not. For lossy decomposition, we must have- R1 ⋈ R2 ⊃ R A B C 1 2 1 2 5 3 2 3 3 3 5 3 3 3 3 This relation is not same as the original relation R and contains some extraneous tuples. Clearly, R1 ⋈ R2 ⊃ R. Thus, we conclude that the above decomposition is lossy join decomposition. Slide 1- 37Slide 1- 38Slide 1- 39","libVersion":"0.5.0","langs":""}