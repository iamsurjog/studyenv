{"path":"sem5/DBMS/pdfs/Module-4_Module 4 Query optimisation.pdf","text":"Copyright © 2016 Ramez Elmasri and Shamkant B. NavatheCopyright © 2016 Ramez Elmasri and Shamkant B. Navathe CHAPTER 18 Strategies for Query Processing Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Introduction n DBMS techniques to process a query n Scanner identifies query tokens n Parser checks the query syntax n Validation checks all attribute and relation names n Query tree (or query graph) created n Execution strategy or query plan devised n Query optimization n Planning a good execution strategy Slide 18- 3Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Query Processing Slide 18-4 Figure 18.1 Typical steps when processing a high-level query Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe 18.1 Translating SQL Queries into Relational Algebra and Other Operators n SQL n Query language used in most RDBMSs n Query decomposed into query blocks n Basic units that can be translated into the algebraic operators n Contains single SELECT-FROM-WHERE expression n May contain GROUP BY and HAVING clauses Slide 18- 5Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Translating SQL Queries (cont’d.) n Example: n Inner block n Outer block Slide 18- 6Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Translating SQL Queries (cont’d.) n Example (cont’d.) n Inner block translated into: n Outer block translated into: n Query optimizer chooses execution plan for each query block Slide 18- 7Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Additional Operators Semi-Join and Anti-Join n Semi-join n Generally used for unnesting EXISTS, IN, and ANY subqueries n Syntax: T1.X S = T2.Y n T1 is the left table and T2 is the right table of the semi-join n A row of T1 is returned as soon as T1.X finds a match with any value of T2.Y without searching for further matches Slide 18- 8Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Additional Operators Semi-Join and Anti-Join (cont’d.) n Anti-join n Used for unnesting NOT EXISTS, NOT IN, and ALL subqueries n Syntax: T1.x A = T2.y n T1 is the left table and T2 is the right table of the anti-join n A row of T1 is rejected as soon as T1.x finds a match with any value of T2.y n A row of T1 is returned only if T1.x does not match with any value of T2.y Slide 18- 9Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe 18.2 Algorithms for External Sorting n Sorting is an often-used algorithm in query processing n External sorting n Algorithms suitable for large files that do not fit entirely in main memory n Sort-merge strategy based on sorting smaller subfiles (runs) and merging the sorted runs n Requires buffer space in main memory n DBMS cache Slide 18- 10Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Slide 18-11 Figure 18.2 Outline of the sort-merge algorithm for external sorting Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Algorithms for External Sorting (cont’d.) n Degree of merging n Number of sorted subfiles that can be merged in each merge step n Performance of the sort-merge algorithm n Number of disk block reads and writes before sorting is completed Slide 18- 12Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe 18.3 Algorithms for SELECT Operation n SELECT operation n Search operation to locate records in a disk file that satisfy a certain condition n File scan or index scan (if search involves an index) n Search methods for simple selection n S1: Linear search (brute force algorithm) n S2: Binary search n S3a: Using a primary index n S3b: Using a hash key Slide 18- 13Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Algorithms for SELECT Operation (cont’d.) n Search methods for simple selection (cont’d.) n S4: Using a primary index to retrieve multiple records n S5: Using a clustering index to retrieve multiple records n S6: Using a secondary (B+ -tree) index on an equality comparison n S7a: Using a bitmap index n S7b: Using a functional index Slide 18- 14Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Algorithms for SELECT Operation (cont’d.) n Search methods for conjunctive (logical AND) selection n Using an individual index n Using a composite index n Intersection of record pointers n Disjunctive (logical OR) selection n Harder to process and optimize Slide 18- 15Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Algorithms for SELECT Operation (cont’d.) n Selectivity n Ratio of the number of records (tuples) that satisfy the condition to the total number of records (tuples) in the file n Number between zero (no records satisfy condition) and one (all records satisfy condition) n Query optimizer receives input from system catalog to estimate selectivity Slide 18- 16Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe 18.4 Implementing the JOIN Operation n JOIN operation n One of the most time consuming in query processing n EQUIJOIN (NATURAL JOIN) n Two-way or multiway joins n Methods for implementing joins n J1: Nested-loop join (nested-block join) n J2: Index-based nested-loop join n J3: Sort-merge join n J4: Partition-hash join Slide 18- 17Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Implementing the JOIN Operation (cont’d.) Slide 18-18 Figure 18.3 Implementing JOIN, PROJECT, UNION, INTERSECTION, and SET DIFFERENCE by using sort-merge, where R has n tuples and S has m tuples. (a) Implementing the operation Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Implementing the JOIN Operation (cont’d.) Slide 18-19 Figure 18.3 (cont’d.) Implementing JOIN, PROJECT, UNION, INTERSECTION, and SET DIFFERENCE by using sort-merge, where R has n tuples and S has m tuples. (b) Implementing the operation Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Implementing the JOIN Operation (cont’d.) Slide 18-20 Figure 18.3 (cont’d.) Implementing JOIN, PROJECT, UNION, INTERSECTION, and SET DIFFERENCE by using sort-merge, where R has n tuples and S has m tuples. (c) Implementing the operation Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Implementing the JOIN Operation (cont’d.) Slide 18-21 Figure 18.3 (cont’d.) Implementing JOIN, PROJECT, UNION, INTERSECTION, and SET DIFFERENCE by using sort-merge, where R has n tuples and S has m tuples. (d) Implementing the operation Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Implementing the JOIN Operation (cont’d.) Slide 18-22 Figure 18.3 (cont’d.) Implementing JOIN, PROJECT, UNION, INTERSECTION, and SET DIFFERENCE by using sort-merge, where R has n tuples and S has m tuples. (e) Implementing the operation Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Implementing the JOIN Operation (cont’d.) n Available buffer space has important effect on some JOIN algorithms n Nested-loop approach n Read as many blocks as possible at a time into memory from the file whose records are used for the outer loop n Advantageous to use the file with fewer blocks as the outer-loop file Slide 18- 23Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Implementing the JOIN Operation (cont’d.) n Join selection factor n Fraction of records in one file that will be joined with records in another file n Depends on the particular equijoin condition with another file n Affects join performance n Partition-hash join n Each file is partitioned into M partitions using the same partitioning hash function on the join attributes n Each pair of corresponding partitions is joined Slide 18- 24Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Implementing the JOIN Operation (cont’d.) n Hybrid hash-join n Variation of partition hash-join n Joining phase for one of the partitions is included in the partition n Goal: join as many records during the partitioning phase to save cost of storing records on disk and then rereading during the joining phase Slide 18- 25Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe 18.5 Algorithms for PROJECT and Set Operations n PROJECT operation n After projecting R on only the columns in the list of attributes, any duplicates are removed by treating the result strictly as a set of tuples n Default for SQL queries n No elimination of duplicates from the query result n Duplicates eliminated only if the keyword DISTINCT is included Slide 18- 26Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Algorithms for PROJECT and Set Operations (cont’d.) n Set operations n UNION n INTERSECTION n SET DIFFERENCE n CARTESIAN PRODUCT n Set operations sometimes expensive to implement n Sort-merge technique n Hashing Slide 18- 27Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Algorithms for PROJECT and Set Operations (cont’d.) n Use of anti-join for SET DIFFERENCE n EXCEPT or MINUS in SQL n Example: Find which departments have no employees becomes Slide 18- 28Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe 18.6 Implementing Aggregate Operations and Different Types of JOINs n Aggregate operators n MIN, MAX, COUNT, AVERAGE, SUM n Can be computed by a table scan or using an appropriate index n Example: n If an (ascending) B+ -tree index on Salary exists: n Optimizer can use the Salary index to search for the largest Salary value n Follow the rightmost pointer in each index node from the root to the rightmost leaf Slide 18- 29Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Implementing Aggregate Operations and Different Types of JOINs (cont’d.) n AVERAGE or SUM n Index can be used if it is a dense index n Computation applied to the values in the index n Nondense index can be used if actual number of records associated with each index value is stored in each index entry n COUNT n Number of values can be computed from the index Slide 18- 30Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Implementing Aggregate Operations and Different Types of JOINs (cont’d.) n Standard JOIN (called INNER JOIN in SQL) n Variations of joins n Outer join n Left, right, and full n Example: n Semi-Join n Anti-Join n Non-Equi-Join Slide 18- 31Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe 18.7 Combining Operations Using Pipelining n SQL query translated into relational algebra expression n Sequence of relational operations n Materialized evaluation n Creating, storing, and passing temporary results n General query goal: minimize the number of temporary files n Pipelining or stream-based processing n Combines several operations into one n Avoids writing temporary files Slide 18- 32Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Combining Operations Using Pipelining (cont’d.) n Pipelined evaluation benefits n Avoiding cost and time delay associated with writing intermediate results to disk n Being able to start generating results as quickly as possible n Iterator n Operation implemented in such a way that it outputs one tuple at a time n Many iterators may be active at one time Slide 18- 33Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Combining Operations Using Pipelining (cont’d.) n Iterator interface methods n Open() n Get_Next() n Close() n Some physical operators may not lend themselves to the iterator interface concept n Pipelining not supported n Iterator concept can also be applied to access methods Slide 18- 34Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe 18.8 Parallel Algorithms for Query Processing n Parallel database architecture approaches n Shared-memory architecture n Multiple processors can access common main memory region n Shared-disk architecture n Every processor has its own memory n Machines have access to all disks n Shared-nothing architecture n Each processor has own memory and disk storage n Most commonly used in parallel database systems Slide 18- 35Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Parallel Algorithms for Query Processing (cont’d.) n Linear speed-up n Linear reduction in time taken for operations n Linear scale-up n Constant sustained performance by increasing the number of processors and disks Slide 18- 36Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Parallel Algorithms for Query Processing (cont’d.) n Operator-level parallelism n Horizontal partitioning n Round-robin partitioning n Range partitioning n Hash partitioning n Sorting n If data has been range-partitioned on an attribute: n Each partition can be sorted separately in parallel n Results concatenated n Reduces sorting time Slide 18- 37Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Parallel Algorithms for Query Processing (cont’d.) n Selection n If condition is an equality condition on an attribute used for range partitioning: n Perform selection only on partition to which the value belongs n Projection without duplicate elimination n Perform operation in parallel as data is read n Duplicate elimination n Sort tuples and discard duplicates Slide 18- 38Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Parallel Algorithms for Query Processing (cont’d.) n Parallel joins divide the join into n smaller joins n Perform smaller joins in parallel on n processors n Take a union of the result n Parallel join techniques n Equality-based partitioned join n Inequality join with partitioning and replication n Parallel partitioned hash join Slide 18- 39Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Parallel Algorithms for Query Processing (cont’d.) n Aggregation n Achieved by partitioning on the grouping attribute and then computing the aggregate function locally at each processor n Set operations n If argument relations are partitioned using the same hash function, they can be done in parallel on each processor Slide 18- 40Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe Parallel Algorithms for Query Processing (cont’d.) n Intraquery parallelism n Approaches n Use parallel algorithm for each operation, with appropriate partitioning of the data input to that operation n Execute independent operations in parallel n Interquery parallelism n Execution of multiple queries in parallel n Goal: scale up n Difficult to achieve on shared-disk or shared- nothing architectures Slide 18- 41Copyright © 2016 Ramez Elmasri and Shamkant B. Navathe 18.9 Summary n SQL queries translated into relational algebra n External sorting n Selection algorithms n Join operations n Combining operations to create pipelined execution n Parallel database system architectures Slide 18- 42","libVersion":"0.5.0","langs":""}