{"path":"sem5/DBMS/pdfs/Module-6_Module 6.pdf","text":"©Silberschatz, Korth and Sudarshan16.1Database System Concepts 3rd Edition Chapt er 16: Concurrency Cont rolChapt er 16: Concurrency Cont rol  Lock-Based Protocols  Tim estam p-Based Protocols  Validation-Based Protocols  Multiple Granularity  Multiversion Schem es  Deadlock Handling  Insert and Delete Operations  Concurrency in Index Structures ©Silberschatz, Korth and Sudarshan16.2Database System Concepts 3rd Edition Lock-Based Prot ocolsLock-Based Prot ocols  A lock is a m echanism to control concurrent access to a data item  Data item s can be locked in two m odes : 1. exclusive (X) mode. Data item can be both read as well as written. X-lock is requested using lock-X instruction. 2. shared (S) mode. Data item can only be read. S-lock is requested using lock-S instruction.  Lock requests are m ade to concurrency-control m anager. Transaction can proceed only after request is granted. ©Silberschatz, Korth and Sudarshan16.3Database System Concepts 3rd Edition Lock-Based Prot ocols (Cont .)Lock-Based Prot ocols (Cont .)  Lock-com patibility m atrix  A transaction m ay be granted a lock on an item if the requested lock is com patible with locks already held on the item by other transactions  Any num ber of transactions can hold shared locks on an item , but if any transaction holds an exclusive on the item no other transaction m ay hold any lock on the item .  If a lock cannot be granted, the requesting transaction is m ade to wait till all incom patible locks held by other transactions have been released. The lock is then granted. ©Silberschatz, Korth and Sudarshan16.4Database System Concepts 3rd Edition Lock-Based Prot ocols (Cont .)Lock-Based Prot ocols (Cont .)  Example of a transaction perform ing locking: T2: lock-S(A); read (A); unlock(A); lock-S(B); read (B); unlock(B); display(A+B)  Locking as above is not sufficient to guarantee serializability — if A and B get updated in-between the read of A and B, the displayed sum would be wrong.  A locking prot ocol is a set of rules followed by all transactions while requesting and releasing locks. Locking protocols restrict the set of possible schedules. ©Silberschatz, Korth and Sudarshan16.5Database System Concepts 3rd Edition Pit falls of Lock-Based ProtocolsPit falls of Lock-Based Protocols  Consider the partial schedule  Neither T3 nor T4 can m ake progress — executing lock-S(B) causes T4 to wait for T3 to release its lock on B, while executing lock-X(A) causes T3 to wait for T4 to release its lock on A.  Such a situation is called a deadlock.  To handle a deadlock one of T3 or T4 must be rolled back and its locks released. ©Silberschatz, Korth and Sudarshan16.6Database System Concepts 3rd Edition Pit falls of Lock-Based Protocols (Cont.)Pit falls of Lock-Based Protocols (Cont.)  The potential for deadlock exists in m ost locking protocols. Deadlocks are a necessary evil.  St arvation is also possible if concurrency control m anager is badly designed. For exam ple:  A transaction m ay be waiting for an X-lock on an item , while a sequence of other transactions request and are granted an S- lock on the same item.  The same transaction is repeatedly rolled back due to deadlocks.  Concurrency control m anager can be designed to prevent starvation. ©Silberschatz, Korth and Sudarshan16.7Database System Concepts 3rd Edition The Tw o-Phase Locking Prot ocolThe Tw o-Phase Locking Prot ocol  This is a protocol which ensures conflict-serializable schedules.  Phase 1: Growing Phase  transaction may obtain locks  transaction may not release locks  Phase 2: Shrinking Phase  transaction may release locks  transaction may not obtain locks  The protocol assures serializability. It can be proved that the transactions can be serialized in the order of their lock point s (i.e. the point where a transaction acquired its final lock). ©Silberschatz, Korth and Sudarshan16.8Database System Concepts 3rd Edition The Tw o-Phase Locking Prot ocol The Tw o-Phase Locking Prot ocol (Cont .)(Cont .)  Two-phase locking does not ensure freedom from deadlocks  Cascading roll-back is possible under two-phase locking. To avoid this, follow a m odified protocol called st rict t wo-phase locking. Here a transaction m ust hold all its exclusive locks till it com m its/aborts.  Rigorous t wo-phase locking is even stricter: here all locks are held till com m it/abort. In this protocol transactions can be serialized in the order in which they com m it. ©Silberschatz, Korth and Sudarshan16.9Database System Concepts 3rd Edition The Tw o-Phase Locking Prot ocol The Tw o-Phase Locking Prot ocol (Cont .)(Cont .)  There can be conflict serializable schedules that cannot be obtained if two-phase locking is used.  However, in the absence of extra inform ation (e.g., ordering of access to data), two-phase locking is needed for conflict serializability in the following sense: Given a transaction Ti that does not follow two-phase locking, we can find a transaction Tj that uses two-phase locking, and a schedule for Ti and Tj that is not conflict serializable. ©Silberschatz, Korth and Sudarshan16.10Database System Concepts 3rd Edition Lock ConversionsLock Conversions  Two-phase locking with lock conversions: – First Phase:  can acquire a lock-S on item  can acquire a lock-X on item  can convert a lock-S to a lock-X (upgrade) – Second Phase:  can release a lock-S  can release a lock-X  can convert a lock-X to a lock-S (downgrade)  This protocol assures serializability. But still relies on the program m er to insert the various locking instructions. ©Silberschatz, Korth and Sudarshan16.11Database System Concepts 3rd Edition Aut omat ic Acquisition of LocksAut omat ic Acquisition of Locks  A transaction Ti issues the standard read/write instruction, without explicit locking calls.  The operation read(D) is processed as: if Ti has a lock on D then read(D) else begin if necessary wait until no other transaction has a lock-X on D grant Ti a lock-S on D; read(D) end ©Silberschatz, Korth and Sudarshan16.12Database System Concepts 3rd Edition Aut omat ic Acquisition of Locks (Cont.)Aut omat ic Acquisition of Locks (Cont.)  write(D) is processed as: if Ti has a lock-X on D t hen write(D) else begin if necessary wait until no other trans. has any lock on D, if Ti has a lock-S on D t hen upgrade lock on D to lock-X else grant Ti a lock-X on D write(D) end;  All locks are released after com mit or abort ©Silberschatz, Korth and Sudarshan16.13Database System Concepts 3rd Edition I mplementat ion of LockingI mplementat ion of Locking  A Lock manager can be im plem ented as a separate process to which transactions send lock and unlock requests  The lock m anager replies to a lock request by sending a lock grant m essages (or a m essage asking the transaction to roll back, in case of a deadlock)  The requesting transaction waits until its request is answered  The lock m anager m aintains a datastructure called a lock table to record granted locks and pending requests  The lock table is usually im plem ented as an in-m em ory hash table indexed on the nam e of the data item being locked ©Silberschatz, Korth and Sudarshan16.14Database System Concepts 3rd Edition Lock TableLock Table  Black rectangles indicate granted locks, white ones indicate waiting requests  Lock table also records the type of lock granted or requested  New request is added to the end of the queue of requests for the data item , and granted if it is com patible with all earlier locks  Unlock requests result in the request being deleted, and later requests are checked to see if they can now be granted  If transaction aborts, all waiting or granted requests of the transaction are deleted  lock manager may keep a list of locks held by each transaction, to implement this efficiently ©Silberschatz, Korth and Sudarshan16.15Database System Concepts 3rd Edition Graph-Based ProtocolsGraph-Based Protocols  Graph-based protocols are an alternative to two-phase locking  Im pose a partial ordering  on the set D = {d1, d2 ,..., dh} of all data item s.  If di  dj then any transaction accessing both di and dj must access di before accessing dj.  Implies that the set D may now be viewed as a directed acyclic graph, called a database graph.  The tree-protocol is a sim ple kind of graph protocol. ©Silberschatz, Korth and Sudarshan16.16Database System Concepts 3rd Edition Tree Prot ocolTree Prot ocol  Only exclusive locks are allowed.  The first lock by Ti m ay be on any data item . Subsequently, a data Q can be locked by Ti only if the parent of Q is currently locked by Ti.  Data item s m ay be unlocked at any tim e. ©Silberschatz, Korth and Sudarshan16.17Database System Concepts 3rd Edition Graph-Based Protocols (Cont .)Graph-Based Protocols (Cont .)  The tree protocol ensures conflict serializability as well as freedom from deadlock.  Unlocking m ay occur earlier in the tree-locking protocol than in the two-phase locking protocol.  shorter waiting times, and increase in concurrency  protocol is deadlock-free, no rollbacks are required  the abort of a transaction can still lead to cascading rollbacks. (this correction has to be made in the book also.)  However, in the tree-locking protocol, a transaction m ay have to lock data item s that it does not access.  increased locking overhead, and additional waiting tim e  potential decrease in concurrency  Schedules not possible under two-phase locking are possible under tree protocol, and vice versa. ©Silberschatz, Korth and Sudarshan16.18Database System Concepts 3rd Edition Timestamp-Based Prot ocolsTimestamp-Based Prot ocols  Each transaction is issued a tim estam p when it enters the system . If an old transaction Ti has tim e-stam p TS(Ti), a new transaction Tj is assigned tim e-stam p TS(Tj) such that TS(Ti) <TS(Tj).  The protocol m anages concurrent execution such that the tim e- stam ps determ ine the serializability order.  In order to assure such behavior, the protocol m aintains for each data Q two tim estam p values:  W-timest amp(Q) is the largest time-stamp of any transaction that executed write(Q) successfully.  R-t imestamp(Q) is the largest time-stamp of any transaction that executed read(Q) successfully. ©Silberschatz, Korth and Sudarshan16.19Database System Concepts 3rd Edition Timestamp-Based Prot ocols (Cont .)Timestamp-Based Prot ocols (Cont .)  The tim estam p ordering protocol ensures that any conflicting read and write operations are executed in tim estam p order.  Suppose a transaction Ti issues a read(Q) 1. If TS(Ti)  W-tim estam p(Q), then Ti needs to read a value of Q that was already overwritten. Hence, the read operation is rejected, and Ti is rolled back. 2. If TS(Ti) W-tim estam p(Q), then the read operation is executed, and R-tim estam p(Q) is set to the m axim um of R- tim estam p(Q) and TS(Ti). ©Silberschatz, Korth and Sudarshan16.20Database System Concepts 3rd Edition Timestamp-Based Prot ocols (Cont .)Timestamp-Based Prot ocols (Cont .)  Suppose that transaction Ti issues write(Q).  If TS(Ti) < R-timestamp(Q), then the value of Q that Ti is producing was needed previously, and the system assumed that that value would never be produced. Hence, the write operation is rejected, and Ti is rolled back.  If TS(Ti) < W-timestamp(Q), then Ti is attempting to write an obsolete value of Q. Hence, this write operation is rejected, and Ti is rolled back.  Otherwise, the write operation is executed, and W- timestamp(Q) is set to TS(Ti). ©Silberschatz, Korth and Sudarshan16.21Database System Concepts 3rd Edition Example Use of t he ProtocolExample Use of t he Protocol A partial schedule for several data item s for transactions with tim estam ps 1, 2, 3, 4, 5 T1 T2 T3 T4 T5 read(Y) read(X) read(Y) write(Y) write(Z) read(Z) read(X) abort read(X) write(Z) abort write(Y) write(Z) ©Silberschatz, Korth and Sudarshan16.22Database System Concepts 3rd Edition Correctness of Timestamp-Ordering ProtocolCorrectness of Timestamp-Ordering Protocol  The tim estam p-ordering protocol guarantees serializability since all the arcs in the precedence graph are of the form : Thus, there will be no cycles in the precedence graph  Tim estam p protocol ensures freedom from deadlock as no transaction ever waits.  But the schedule m ay not be cascade-free, and m ay not even be recoverable. transaction with sm aller timestam p transaction with larger timestam p ©Silberschatz, Korth and Sudarshan16.23Database System Concepts 3rd Edition Recoverabilit y and Cascade FreedomRecoverabilit y and Cascade Freedom  Problem with tim estam p-ordering protocol:  Suppose Ti aborts, but Tj has read a data item written by Ti  Then Tj must abort; if Tj had been allowed to comm it earlier, the schedule is not recoverable.  Further, any transaction that has read a data item written by Tj must abort  This can lead to cascading rollback --- that is, a chain of rollbacks  Solution:  A transaction is structured such that its writes are all perform ed at the end of its processing  All writes of a transaction form an atom ic action; no transaction may execute while a transaction is being written  A transaction that aborts is restarted with a new timestam p ©Silberschatz, Korth and Sudarshan16.24Database System Concepts 3rd Edition Thomas’ Write RuleThomas’ Write Rule  Modified version of the tim estam p-ordering protocol in which obsolete writ e operations m ay be ignored under certain circum stances.  When Ti attem pts to write data item Q, if TS(Ti) < W- tim estam p(Q), then Ti is attem pting to write an obsolete value of {Q}. Hence, rather than rolling back Ti as the tim estam p ordering protocol would have done, this {writ e} operation can be ignored.  Otherwise this protocol is the sam e as the tim estam p ordering protocol.  Thom as' Write Rule allows greater potential concurrency. Unlike previous protocols, it allows som e view-serializable schedules that are not conflict-serializable. ©Silberschatz, Korth and Sudarshan16.25Database System Concepts 3rd Edition Validat ion-Based Prot ocolValidat ion-Based Prot ocol  Execution of transaction Ti is done in three phases. 1. Read and execution phase: Transaction Ti writes only to temporary local variables 2. Validation phase: Transaction Ti performs a ``validation test'' to determine if local variables can be written without violating serializability. 3. Write phase: If Ti is validated, the updates are applied to the database; otherwise, Ti is rolled back.  The three phases of concurrently executing transactions can be interleaved, but each transaction must go through the three phases in that order.  Also called as optimistic concurrency control since transaction executes fully in the hope that all will go well during validation ©Silberschatz, Korth and Sudarshan16.26Database System Concepts 3rd Edition Validat ion-Based Prot ocol (Cont.)Validat ion-Based Prot ocol (Cont.)  Each transaction Ti has 3 timestamps  Start (Ti) : the time when Ti started its execution  Validation(Ti): the time when Ti entered its validation phase  Finish(Ti) : the time when Ti finished its write phase  Serializability order is determined by timestamp given at validation time, to increase concurrency. Thus TS(Ti) is given the value of Validation(Ti).  This protocol is useful and gives greater degree of concurrency if probability of conflicts is low. That is because the serializability order is not pre-decided and relatively less transactions will have to be rolled back. ©Silberschatz, Korth and Sudarshan16.27Database System Concepts 3rd Edition Validat ion Test for Transaction Validat ion Test for Transaction TTjj  If for all Ti with TS (Ti) < TS (Tj) either one of the following condition holds:  finish(Ti) < st art (Tj)  st art (Tj) < finish(Ti) < validat ion(Tj) and the set of data item s written by Ti does not intersect with the set of data item s read by Tj. then validation succeeds and Tj can be committed. Otherwise, validation fails and Tj is aborted.  Justifi cation: Either first condition is satisfied, and there is no overlapped execution, or second condition is satisfied and 1. the writes of Tj do not aff ect reads of Ti since they occur after Ti has finished its reads. 2. the writes of Ti do not aff ect reads of Tj since Tj does not read any item written by Ti. ©Silberschatz, Korth and Sudarshan16.28Database System Concepts 3rd Edition Schedule Produced by Validat ionSchedule Produced by Validat ion  Exam ple of schedule produced using validation T14 T15 read(B) read(B) B:- B-50 read(A) A:- A+50 read(A) (validate) display (A+B) (validate) writ e (B) writ e (A) ©Silberschatz, Korth and Sudarshan16.29Database System Concepts 3rd Edition M ultiple Granularit yM ultiple Granularit y  Allow data item s to be of various sizes and define a hierarchy of data granularities, where the sm all granularities are nested within larger ones  Can be represented graphically as a tree (but don't confuse with tree-locking protocol)  When a transaction locks a node in the tree explicitly, it implicitly locks all the node's descendents in the sam e m ode.  Granularity of locking (level in tree where locking is done):  fi ne granularity (lower in tree): high concurrency, high locking overhead  coarse granularity (higher in tree): low locking overhead, low concurrency ©Silberschatz, Korth and Sudarshan16.30Database System Concepts 3rd Edition Example of Granularity HierarchyExample of Granularity Hierarchy The highest level in the exam ple hierarchy is the entire database. The levels below are of type area, fi le and record in that order. ©Silberschatz, Korth and Sudarshan16.31Database System Concepts 3rd Edition I ntention Lock M odesI ntention Lock M odes  In addition to S and X lock m odes, there are three additional lock m odes with m ultiple granularity:  intention-shared (IS): indicates explicit locking at a lower level of the tree but only with shared locks.  intention-exclusive (IX): indicates explicit locking at a lower level with exclusive or shared locks  shared and intention-exclusive (SIX): the subtree rooted by that node is locked explicitly in shared mode and explicit locking is being done at a lower level with exclusive-mode locks.  intention locks allow a higher level node to be locked in S or X m ode without having to check all descendent nodes. ©Silberschatz, Korth and Sudarshan16.32Database System Concepts 3rd Edition Compatibility M atrix withCompatibility M atrix with I ntention Lock M odes I ntention Lock M odes  The com patibility m atrix for all lock m odes is: IS IX S S IX X IS IX S S IX X                       ©Silberschatz, Korth and Sudarshan16.33Database System Concepts 3rd Edition M ultiple Granularit y Locking SchemeM ultiple Granularit y Locking Scheme  Transaction Ti can lock a node Q, using the following rules: 1. The lock com patibility matrix m ust be observed. 2. The root of the tree m ust be locked first, and may be locked in any m ode. 3. A node Q can be locked by Ti in S or IS m ode only if the parent of Q is currently locked by Ti in either IX or IS m ode. 4. A node Q can be locked by Ti in X, SIX, or IX mode only if the parent of Q is currently locked by Ti in either IX or SIX mode. 5. Ti can lock a node only if it has not previously unlocked any node (that is, Ti is two-phase). 6. Ti can unlock a node Q only if none of the children of Q are currently locked by Ti.  Observe that locks are acquired in root-to-leaf order, whereas they are released in leaf-to-root order. ©Silberschatz, Korth and Sudarshan16.34Database System Concepts 3rd Edition M ultiversion SchemesM ultiversion Schemes  Multiversion schem es keep old versions of data item to increase concurrency.  Multiversion Tim estam p Ordering  Multiversion Two-Phase Locking  Each successful writ e results in the creation of a new version of the data item written.  Use tim estam ps to label versions.  When a read(Q) operation is issued, select an appropriate version of Q based on the tim estam p of the transaction, and return the value of the selected version.  reads never have to wait as an appropriate version is returned im m ediately. ©Silberschatz, Korth and Sudarshan16.35Database System Concepts 3rd Edition M ultiversion Timestamp OrderingM ultiversion Timestamp Ordering  Each data item Q has a sequence of versions <Q1, Q2,...., Qm>. Each version Qk contains three data fields:  Content -- the value of version Qk.  W-timest amp(Qk) -- tim estamp of the transaction that created (wrote) version Qk  R-t imestamp(Qk) -- largest timestam p of a transaction that successfully read version Qk  when a transaction Ti creates a new version Qk of Q, Qk's W- tim estam p and R-tim estam p are initialized to TS(Ti).  R-tim estam p of Qk is updated whenever a transaction Tj reads Qk, and TS(Tj) > R-tim estam p(Qk). ©Silberschatz, Korth and Sudarshan16.36Database System Concepts 3rd Edition M ultiversion Timestamp Ordering M ultiversion Timestamp Ordering (Cont )(Cont )  The multiversion timestamp scheme presented next ensures serializability.  Suppose that transaction Ti issues a read(Q) or write(Q) operation. Let Qk denote the version of Q whose write timestamp is the largest write timestamp less than or equal to TS(Ti). 1. If transaction Ti issues a read(Q), then the value returned is the content of version Qk. 2. If transaction Ti issues a write(Q), and if TS(Ti) < R- timestamp(Qk), then transaction Ti is rolled back. Otherwise, if TS(Ti) = W-timestamp(Qk), the contents of Qk are overwritten, otherwise a new version of Q is created.  Reads always succeed; a write by Ti is rejected if some other transaction Tj that (in the serialization order defined by the timestamp values) should read Ti's write, has already read a version created by a transaction older than Ti. ©Silberschatz, Korth and Sudarshan16.37Database System Concepts 3rd Edition M ultiversion Tw o-Phase LockingM ultiversion Tw o-Phase Locking  Diff erentiates between read-only transactions and update transactions  Update transactions acquire read and write locks, and hold all locks up to the end of the transaction. That is, update transactions follow rigorous two-phase locking.  Each successful write results in the creation of a new version of the data item written.  each version of a data item has a single timestam p whose value is obtained from a counter ts-count er that is increm ented during comm it processing.  Read-only transactions are assigned a tim estam p by reading the current value of ts-count er before they start execution; they follow the m ultiversion tim estam p-ordering protocol for perform ing reads. ©Silberschatz, Korth and Sudarshan16.38Database System Concepts 3rd Edition M ultiversion Tw o-Phase Locking M ultiversion Tw o-Phase Locking (Cont .)(Cont .)  When an update transaction wants to read a data item , it obtains a shared lock on it, and reads the latest version.  When it wants to write an item , it obtains X lock on; it then creates a new version of the item and sets this version's tim estam p to .  When update transaction Ti com pletes, com m it processing occurs:  Ti sets tim estam p on the versions it has created to ts-count er + 1  Ti increm ents ts-count er by 1  Read-only transactions that start after Ti increm ents ts- count er will see the values updated by Ti.  Read-only transactions that start before Ti increm ents the ts-count er will see the value before the updates by Ti.  Only serializable schedules are produced. ©Silberschatz, Korth and Sudarshan16.39Database System Concepts 3rd Edition Deadlock HandlingDeadlock Handling  Consider the following two transactions: T1: write (X) T2: write(Y) write(Y) write(X)  Schedule with deadlock T1 T2 lock-X on X write (X) lock-X on Y write (X) wait for lock-X on X wait for lock-X on Y ©Silberschatz, Korth and Sudarshan16.40Database System Concepts 3rd Edition Deadlock HandlingDeadlock Handling  System is deadlocked if there is a set of transactions such that every transaction in the set is waiting for another transaction in the set.  Deadlock prevention protocols ensure that the system will never enter into a deadlock state. Some prevention strategies :  Require that each transaction locks all its data item s before it begins execution (predeclaration).  Im pose partial ordering of all data item s and require that a transaction can lock data item s only in the order specified by the partial order (graph-based protocol). ©Silberschatz, Korth and Sudarshan16.41Database System Concepts 3rd Edition M ore Deadlock Prevent ion Strat egiesM ore Deadlock Prevent ion Strat egies  Following schem es use transaction tim estam ps for the sake of deadlock prevention alone.  wait-die schem e — non-preem ptive  older transaction may wait for younger one to release data item . Younger transactions never wait for older ones; they are rolled back instead.  a transaction m ay die several tim es before acquiring needed data item  wound-wait schem e — preem ptive  older transaction wounds (forces rollback) of younger transaction instead of waiting for it. Younger transactions m ay wait for older ones.  may be fewer rollbacks than wait-die schem e. ©Silberschatz, Korth and Sudarshan16.42Database System Concepts 3rd Edition Deadlock prevention (Cont .)Deadlock prevention (Cont .)  Both in wait-die and in wound-wait schem es, a rolled back transactions is restarted with its original tim estam p. Older transactions thus have precedence over newer ones, and starvation is hence avoided.  Tim eout-Based Schem es :  a transaction waits for a lock only for a specified am ount of time. After that, the wait times out and the transaction is rolled back.  thus deadlocks are not possible  sim ple to im plem ent; but starvation is possible. Also difficult to determ ine good value of the timeout interval. ©Silberschatz, Korth and Sudarshan16.43Database System Concepts 3rd Edition Deadlock Det ect ionDeadlock Det ect ion  Deadlocks can be described as a wait-for graph, which consists of a pair G = (V,E),  V is a set of vertices (all the transactions in the system )  E is a set of edges; each elem ent is an ordered pair Ti Tj.  If Ti  Tj is in E, then there is a directed edge from Ti to Tj, im plying that Ti is waiting for Tj to release a data item .  When Ti requests a data item currently being held by Tj, then the edge Ti Tj is inserted in the wait-for graph. This edge is rem oved only when Tj is no longer holding a data item needed by Ti.  The system is in a deadlock state if and only if the wait-for graph has a cycle. Must invoke a deadlock-detection algorithm periodically to look for cycles. ©Silberschatz, Korth and Sudarshan16.44Database System Concepts 3rd Edition Deadlock Det ect ion (Cont .)Deadlock Det ect ion (Cont .) Wait-for graph without a cycle Wait-for graph with a cycle ©Silberschatz, Korth and Sudarshan16.45Database System Concepts 3rd Edition Deadlock RecoveryDeadlock Recovery  When deadlock is detected :  Som e transaction will have to rolled back (m ade a victim) to break deadlock. Select that transaction as victim that will incur minim um cost.  Rollback -- determ ine how far to roll back transaction  To tal rollback: Abort the transaction and then restart it.  More eff ective to roll back transaction only as far as necessary to break deadlock.  Starvation happens if same transaction is always chosen as victim . Include the num ber of rollbacks in the cost factor to avoid starvation ©Silberschatz, Korth and Sudarshan16.46Database System Concepts 3rd Edition I nsert and Delete Operat ionsI nsert and Delete Operat ions  If two-phase locking is used :  A delet e operation may be perform ed only if the transaction deleting the tuple has an exclusive lock on the tuple to be deleted.  A transaction that inserts a new tuple into the database is given an X-m ode lock on the tuple  Insertions and deletions can lead to the phant om phenomenon.  A transaction that scans a relation (e.g., find all accounts in Perryridge) and a transaction that inserts a tuple in the relation (e.g., insert a new account at Perryridge) m ay conflict in spite of not accessing any tuple in com mon.  If only tuple locks are used, non-serializable schedules can result: the scan transaction may not see the new account, yet may be serialized before the insert transaction. ©Silberschatz, Korth and Sudarshan16.47Database System Concepts 3rd Edition I nsert and Delet e Operat ions (Cont .)I nsert and Delet e Operat ions (Cont .)  The transaction scanning the relation is reading inform ation that indicates what tuples the relation contains, while a transaction inserting a tuple updates the sam e inform ation.  The inform ation should be locked.  One solution:  Associate a data item with the relation, to represent the information about what tuples the relation contains.  Transactions scanning the relation acquire a shared lock in the data item,  Transactions inserting or deleting a tuple acquire an exclusive lock on the data item. (Note: locks on the data item do not conflict with locks on individual tuples.)  Above protocol provides very low concurrency for insertions/deletions.  Index locking protocols provide higher concurrency while preventing the phantom phenom enon, by requiring locks on certain index buckets. ©Silberschatz, Korth and Sudarshan16.48Database System Concepts 3rd Edition I ndex Locking Prot ocolI ndex Locking Prot ocol  Every relation must have at least one index. Access to a relation must be made only through one of the indices on the relation.  A transaction Ti that performs a lookup must lock all the index buckets that it accesses, in S-mode.  A transaction Ti may not insert a tuple ti into a relation r without updating all indices to r.  Ti must perform a lookup on every index to find all index buckets that could have possibly contained a pointer to tuple ti, had it existed already, and obtain locks in X-mode on all these index buckets. Ti must also obtain locks in X-mode on all index buckets that it modifies.  The rules of the two-phase locking protocol must be observed. ©Silberschatz, Korth and Sudarshan16.49Database System Concepts 3rd Edition Weak Levels of Consist encyWeak Levels of Consist ency  Degree-t wo consist ency: diff ers from two-phase locking in that S-locks m ay be released at any tim e, and locks m ay be acquired at any tim e  X-locks m ust be held till end of transaction  Serializability is not guaranteed, programm er must ensure that no erroneous database state will occur]  Cursor st abilit y:  For reads, each tuple is locked, read, and lock is imm ediately released  X-locks are held till end of transaction  Special case of degree-two consistency ©Silberschatz, Korth and Sudarshan16.50Database System Concepts 3rd Edition Weak Levels of Consist ency in SQLWeak Levels of Consist ency in SQL  SQL allows non-serializable executions  Serializable: is the default  Repeat able read: allows only comm itted records to be read, and repeating a read should return the same value (so read locks should be retained)  However, the phantom phenom enon need not be prevented – T1 m ay see some records inserted by T2, but m ay not see others inserted by T2  Read committ ed: sam e as degree two consistency, but m ost system s im plem ent it as cursor-stability  Read uncommit ted: allows even uncom m itted data to be read ©Silberschatz, Korth and Sudarshan16.51Database System Concepts 3rd Edition Concurrency in I ndex Struct uresConcurrency in I ndex Struct ures  Indices are unlike other database item s in that their only job is to help in accessing data.  Index-structures are typically accessed very often, m uch m ore than other database item s.  Treating index-structures like other database item s leads to low concurrency. Two-phase locking on an index m ay result in transactions executing practically one-at-a-tim e.  It is acceptable to have nonserializable concurrent access to an index as long as the accuracy of the index is m aintained.  In particular, the exact values read in an internal node of a B +-tree are irrelevant so long as we land up in the correct leaf node.  There are index concurrency protocols where locks on internal nodes are released early, and not in a two-phase fashion. ©Silberschatz, Korth and Sudarshan16.52Database System Concepts 3rd Edition Concurrency in I ndex Struct ures Concurrency in I ndex Struct ures (Cont .)(Cont .)  Exam ple of index concurrency protocol:  Use crabbing instead of two-phase locking on the nodes of the B +-tree, as follows. During search/insertion/deletion:  First lock the root node in shared m ode.  After locking all required children of a node in shared m ode, release the lock on the node.  During insertion/deletion, upgrade leaf node locks to exclusive mode.  When splitting or coalescing requires changes to a parent, lock the parent in exclusive mode.  Above protocol can cause excessive deadlocks. Better protocols are available; see Section 16.9 for one such protocol, the B-link tree protocol End of ChapterEnd of Chapter ©Silberschatz, Korth and Sudarshan16.54Database System Concepts 3rd Edition Partial Schedule Under Tw o-Phase Partial Schedule Under Tw o-Phase LockingLocking ©Silberschatz, Korth and Sudarshan16.55Database System Concepts 3rd Edition I ncomplete Schedule With a Lock I ncomplete Schedule With a Lock ConversionConversion ©Silberschatz, Korth and Sudarshan16.56Database System Concepts 3rd Edition Lock TableLock Table ©Silberschatz, Korth and Sudarshan16.57Database System Concepts 3rd Edition Tree-St ructured Database GraphTree-St ructured Database Graph ©Silberschatz, Korth and Sudarshan16.58Database System Concepts 3rd Edition Serializable Schedule Under the Tree Serializable Schedule Under the Tree ProtocolProtocol ©Silberschatz, Korth and Sudarshan16.59Database System Concepts 3rd Edition Schedule 3Schedule 3 ©Silberschatz, Korth and Sudarshan16.60Database System Concepts 3rd Edition Schedule 4Schedule 4 ©Silberschatz, Korth and Sudarshan16.61Database System Concepts 3rd Edition Schedule 5, A Schedule Produced by Using Schedule 5, A Schedule Produced by Using ValidationValidation ©Silberschatz, Korth and Sudarshan16.62Database System Concepts 3rd Edition Granularity HierarchyGranularity Hierarchy ©Silberschatz, Korth and Sudarshan16.63Database System Concepts 3rd Edition Compat ibility M at rixCompat ibility M at rix ©Silberschatz, Korth and Sudarshan16.64Database System Concepts 3rd Edition Wait-for Graph Wit h No CycleWait-for Graph Wit h No Cycle ©Silberschatz, Korth and Sudarshan16.65Database System Concepts 3rd Edition Wait-for-graph Wit h A CycleWait-for-graph Wit h A Cycle ©Silberschatz, Korth and Sudarshan16.66Database System Concepts 3rd Edition Nonserializable Schedule with Degree-Tw o Nonserializable Schedule with Degree-Tw o ConsistencyConsistency ©Silberschatz, Korth and Sudarshan16.67Database System Concepts 3rd Edition BB++-Tree For -Tree For accountaccount File with File with nn = 3.= 3. ©Silberschatz, Korth and Sudarshan16.68Database System Concepts 3rd Edition I nsert ion of “Clearview” I nt o t he BI nsert ion of “Clearview” I nt o t he B++-Tree of Figure -Tree of Figure 16.2116.21 ©Silberschatz, Korth and Sudarshan16.69Database System Concepts 3rd Edition Lock-Compat ibility M at rixLock-Compat ibility M at rix","libVersion":"0.5.0","langs":""}