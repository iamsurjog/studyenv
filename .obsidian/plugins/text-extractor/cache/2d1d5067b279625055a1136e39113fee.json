{"path":"sem5/DBMS/pdfs/Module-4_Module 4_ Introduction_1.pdf","text":"Module 4 Physical Database Design and Query File Organization - Indexing: Single level indexing, multi-level indexing, dynamic multilevel Indexing - B+ Tree Indexing ‚Äì Hashing Techniques: Static and Dynamic Hashing ‚Äì Relational Algebra - Translating SQL Queries into Relational Algebra ‚Äì Query Processing ‚Äì Query Optimization: Algebraic Query Optimization, Heuristic query optimization Rules, Join Query Optimization using Indexing and Hashing - Tuple Relational Calculus. Reference : R. Elmasri & S. B. Navathe, Fundamentals of Database Systems, Addison Wesley, 7th Edition, 2016 A. Silberschatz, H. F. Korth & S. Sudarshan, Database System Concepts, McGraw Hill,7th Edition 2019. Indexing and Hashing ÔÅÆ Basic Concepts ÔÅÆ Ordered Indices ÔÅÆ B+-Tree Index Files ÔÅÆ B-Tree Index Files ÔÅÆ Static Hashing ÔÅÆ Dynamic Hashing ÔÅÆ Comparison of Ordered Indexing and Hashing ÔÅÆ Index Definition in SQL ÔÅÆ Multiple-Key Access Introduction ‚Ä¢ Database data must be stored physically on storage media. ‚Ä¢ DBMS retrieves, updates, and processes stored data. ‚Ä¢ Storage hierarchy consists of primary, secondary, and tertiary storage. Primary Storage ‚Ä¢ Operated directly by CPU (e.g., main memory, cache memory). ‚Ä¢ Provides fast access to data. ‚Ä¢ Limited storage capacity compared to enterprise database needs. ‚Ä¢ Expensive relative to disks. ‚Ä¢ Volatile ‚Äì data lost during power failure or system crash. Secondary Storage ‚Ä¢ Primary medium for online storage of enterprise databases. ‚Ä¢ Traditionally magnetic disks used. ‚Ä¢ Flash memory (SSDs) increasingly popular. ‚Ä¢ Non-volatile and permanent storage. ‚Ä¢ Suitable for large databases. Tertiary Storage ‚Ä¢ Optical disks (CD-ROM, DVD) and tapes used for archiving. ‚Ä¢ Removable, offline storage. ‚Ä¢ Provides large capacity at lower cost. ‚Ä¢ Slower access compared to primary/secondary. ‚Ä¢ Data must be copied to primary storage before CPU can process. Memory Hierarchies and Storage Devices Memory Hierarchy Concept ‚Ä¢ Data resides in multiple storage levels ‚Üí speed vs. cost trade-off. ‚Ä¢ High-speed memory = expensive, low capacity (e.g., cache). ‚Ä¢ Low-speed memory = cheaper, very high capacity (e.g., tapes). Primary Storage ÔÇß Cache Memory (SRAM) ÔÉº Fastest, most expensive. ÔÉº Used by CPU for prefetching & pipelining. ÔÇß DRAM (Main Memory) ÔÉº Cheaper, larger than cache. ÔÉº Volatile & slower than SRAM. ÔÉº Holds program instructions & data. ÔÉº Now available in GB to hundreds of GB range. ÔÉº Main-memory databases possible ‚Üí useful for real-time applications (e.g., telephone switching). Memory Hierarchies and Storage Devices Secondary & Tertiary Storage ‚Ä¢ Magnetic Disks (HDDs) Traditional medium for databases. ‚Ä¢ Flash Memory (SSD, USB, NAND/NOR flash) ÔÉº Non-volatile, high performance. ÔÉº Used in cameras, mobiles, laptops, USB drives. ÔÉº NAND ‚Üí higher storage capacity per cost. ‚Ä¢ Optical Drives (CD/DVD/Blu-ray) ÔÉº CD: ~700 MB, DVD: 4.5‚Äì15 GB, Blu-ray: 27‚Äì54 GB. ÔÉº Types: CD-ROM (read-only), CD-R/DVD-R (WORM ‚Äì write once, read many). ÔÉº Declining usage due to cheap, high-capacity disks. ‚Ä¢ Magnetic Tapes ÔÉº Used for backup & archiving. ÔÉº Very large capacity (terabytes to petabytes with jukeboxes). ÔÉº Example: NASA EOS satellite data archives. Memory Hierarchies and Storage Devices Storage Measurement Units KB = 1,000 bytes MB = 1 million bytes GB = 1 billion bytes TB = 1,000 GB PB = 1,000 TB (10¬π bytes) ‚Äì now relevant for big science & ‚Åµ enterprise databases. Memory Hierarchies and Storage Devices Type Capacity Access Time Max Bandwidth Cost Main Memory (RAM) 4 GB ‚Äì 1 TB 30 ns 35 GB/s $100 ‚Äì $20K Flash SSD 64 GB ‚Äì 1 TB 50 ¬µs 750 MB/s $50 ‚Äì $600 Flash USB 4 GB ‚Äì 512 GB 100 ¬µs 50 MB/s $2 ‚Äì $200 Magnetic Disk (HDD) 400 GB ‚Äì 8 TB 10 ms 200 MB/s $70 ‚Äì $500 Optical Storage 50 ‚Äì 100 GB 180 ms 72 MB/s ~$100 Magnetic Tape 2.5 ‚Äì 8.5 TB 10‚Äì80 sec 40‚Äì250 MB/s $2.5K ‚Äì $30K Tape Jukebox 25 TB ‚Äì 2.1M TB 10‚Äì80 sec 250 MB/s ‚Äì 1.2 PB/s $3K ‚Äì $1M+ Comparison of Storage Devices (2014 Commodity Prices) Storage Organization of Databases Persistent Data ‚Ä¢ Stored for long periods, accessed repeatedly. ‚Ä¢ Contrast: Transient data exists only during program execution. Why stored on magnetic disks (secondary storage): ‚Ä¢ Databases are too large for main memory. ‚Ä¢ Disk storage is non-volatile, unlike volatile main memory. ‚Ä¢ Cheaper cost per unit compared to primary storage. Emerging Technologies: ‚Ä¢ SSDs may replace magnetic disks in some cases. ‚Ä¢ Future DBs may use different hierarchy levels (main memory ‚Üí SSD ‚Üí tape jukebox). ‚Ä¢ But magnetic disks expected to remain dominant for large DBs. Other Storage Media: ‚Ä¢ Magnetic tapes ‚Äì cheap, used for backup/archiving. ‚Ä¢ Require operator/auto-loader; offline access (slower). ‚Ä¢ Disks ‚Äì online, direct access anytime. Storage Organization of Databases Physical Database Design: ‚Ä¢ DB designers/DBA must know advantages/disadvantages of storage methods. ‚Ä¢ DBMS offers multiple organization techniques. ‚Ä¢ Choice depends on application requirements. Data Access: ‚Ä¢ Applications usually need only a small portion of DB at a time. ‚Ä¢ Process: Disk ‚Üí Main Memory ‚Üí CPU ‚Üí (back to Disk if modified). ‚Ä¢ Data organized as files of records (entities, attributes, relationships). File Organization Techniques: ‚Ä¢ Heap (Unordered file): Records appended without order. ‚Ä¢ Sorted (Sequential file): Ordered by a field (sort key). ‚Ä¢ Hashed file: Uses hash function on a hash key. ‚Ä¢ B-trees (and variants): Tree-based structure for efficient access. Secondary (Auxiliary) Organization: ‚Ä¢ Provides efficient access via alternate fields. ‚Ä¢ Implemented mostly as indexes Secondary Storage Devices (a) A single-sided disk with read/write hardware. (b) A disk pack with read/write hardware. Secondary Storage Devices Different sectororganizations on disk. (a) Sectors subtendinga fixed angle.(b) Sectors maintaining a uniform recording density Techniques to Make Disk Data Access More Efficient 1.Buffering of Data ‚Ä¢Balances speed mismatch between CPU and slow HDD. ‚Ä¢Uses memory buffers to hold data temporarily. ‚Ä¢Double buffering improves throughput. 2.Proper Organization of Data on Disk ‚Ä¢Store related data in contiguous blocks/cylinders. ‚Ä¢Reduces arm movement and seek time. 3.Reading Data Ahead of Request (Prefetching) ‚Ä¢Reads additional consecutive blocks even if not requested. ‚Ä¢Works well for sequential access.Not effective for random access. 4.Proper Scheduling of I/O Requests ‚Ä¢Organizes block access to minimize arm movement. ‚Ä¢Elevator algorithm (SCAN) ‚Üí services requests in one direction, then reverses. 5.Use of Log Disks for Writes ‚Ä¢Dedicated disk (or area) used to store writes sequentially. ‚Ä¢Eliminates seek time. ‚Ä¢Improves write performance but adds cost. 6.Use of SSDs/Flash for Recovery ‚Ä¢SSD/flash used as fast non-volatile buffer for updates. ‚Ä¢Prevents update loss in case of system crash. ‚Ä¢Data later written to HDD during idle times or when buffer is full. Secondary Storage Devices Hardware Description of Disk Devices Magnetic Disks (HDDs): ÔÉº Store large amounts of data. ÔÉº Basic unit: bit (0 or 1 via magnetization). ÔÉº Bits grouped into bytes (8 bits = 1 character, most common). ÔÉº Capacity = number of bytes it can store (modern disks ‚Üí hundreds of GBs to TBs). Disk Structure: ÔÉº Made of thin circular magnetic material, protected by cover. ÔÉº Single-sided (one surface used) or double-sided (both surfaces). ÔÉº Disks assembled into disk packs (multiple disks/surfaces). ÔÉº Common form factors: 3.5 inch, 2.5 inch. ÔÉº Data stored in tracks (concentric circles). ÔÉº Tracks of same diameter across surfaces = cylinder ‚Üí faster retrieval if data stored in one cylinder. Secondary Storage Devices Tracks, Sectors, and Blocks: ÔÉº Disk has thousands of tracks (up to ~152,000). ÔÉº Each track divided into sectors (fixed, hard-coded). ÔÉº Sector sizes: commonly 512 bytes. ÔÉº Tracks also divided into blocks/pages (set during formatting). ÔÉº Typical block sizes: 512 bytes ‚Äì several KB. ÔÉº Several blocks = cluster (transferred as a unit). Read/Write Mechanism: ÔÉº Performed by disk head attached to mechanical arm. ÔÉº Multiple surfaces ‚Üí multiple heads, controlled together by actuator motor. ÔÉº Disk rotates continuously (speed: 5,400 ‚Äì 15,000 rpm). ÔÉº Fixed-head disks: one head per track ‚Üí faster, but costly. ÔÉº Movable-head disks: common, cheaper. Secondary Storage Devices Disk Interfaces: ÔÉº Older: SCSI (Small Computer System Interface). ÔÉº Modern: SATA (Serial ATA) and SAS (Serial Attached SCSI). ÔÉº SATA: common in PCs (1.5 ‚Äì 6 Gbps). ÔÉº SAS: used in servers, better IOPS (Input/Output per second). ÔÉº Drive sizes: ÔÉº 3.5-inch: up to 8 TB, 7,200‚Äì10,000 rpm. ÔÉº 2.5-inch: up to 1.2 TB, up to 15,000 rpm. Disk Access Times: ÔÉº Seek Time: Time to move head to correct track (3‚Äì10 ms). ÔÉº Rotational Delay (Latency): Time for block to rotate under head (depends on rpm; e.g., ~2 ms at 15,000 rpm). ÔÉº Block Transfer Time: Time to actually transfer data (smaller). ÔÉº Total = Seek Time + Rotational Delay + Transfer Time. ÔÉº Access time: ~9 ‚Äì 60 ms. ÔÉº Contiguous block transfer much faster (saves seek/latency). Secondary Storage Devices Performance Bottleneck: ÔÉº Disk I/O is slower compared to CPU/main memory speeds. ÔÉº Hence, file organization techniques try to minimize block transfers. ÔÉº Goal: store related info in contiguous blocks to reduce delays. Secondary Storage Devices Performance Bottleneck: ÔÉº Disk I/O is slower compared to CPU/main memory speeds. ÔÉº Hence, file organization techniques try to minimize block transfers. ÔÉº Goal: store related info in contiguous blocks to reduce delays. Placing File Records on Disk ‚Ä¢ Data in a database is stored as records organized into files. ‚Ä¢ A record: a collection of related data values (fields) representing an entity. ‚Ä¢ A record type: defines the fields and their data types. ‚Ä¢ Files contain sequences of records; placement affects performance Each record describes an entity (e.g., EMPLOYEE). ‚Ä¢ Fields have data types: ÔÉº Numeric: integer, long, floating point ÔÉº String: fixed-length or variable-length ÔÉº Boolean: 0/1 or TRUE/FALSE ÔÉº Date/Time: fixed-size format Example in C: struct employee { char name[30]; char ssn[9]; int salary; int job_code; char department[20]; }; File Types Large Data Items ÔÉº BLOB (Binary Large Object): stores images, audio, video, or free text. ÔÉº Usually stored separately from the main record. ÔÉº Example: CLOB (Character Large Object) for free text. ÔÉº Alternatives: ÔÉò Store as files in file systems ÔÉò Store as files managed by database ÔÉò Break into pieces and store in multiple tuples in separate relation ÔÇß PostgreSQL TOAST ‚Ä¢ Fixed-length records: all records same size. ‚Ä¢ Variable-length records: record sizes differ due to: 1. Variable-length fields (e.g., Name field) 2. Repeating fields (multi-valued) 3. Optional fields 4. Mixed record types File Types- Fixed-Length Records ÔÉº All fields have fixed sizes ‚Üí predictable record length. ÔÉº Example: EMPLOYEE record = 71 bytes ÔÉº Easy to locate field values by byte offset. ÔÉº Limitation: wasted space for optional or repeating fields. ÔÉº Simple approach: ‚Ä¢ Store record i starting from byte n * (i ‚Äì 1), where n is the size of each record. ‚Ä¢ Record access is simple but records may cross blocks ÔÇß Modification: do not allow records to cross block boundaries File Types- Fixed-Length Records ÔÇß Deletion of record i: alternatives: ‚Ä¢ move records i + 1, . . ., n to i, . . . , n ‚Äì 1 ‚Ä¢ move record n to i ‚Ä¢ do not move records, but link all free records on a free list Record 3 deleted File Types- Fixed-Length Records ÔÇß Deletion of record i: alternatives: ‚Ä¢ move records i + 1, . . ., n to i, . . . , n ‚Äì 1 ‚Ä¢ move record n to i ‚Ä¢ do not move records, but link all free records on a free list Record 3 deleted and replaced by record 11 File Types- Fixed-Length Records ÔÇß Deletion of record i: alternatives: ‚Ä¢ move records i + 1, . . ., n to i, . . . , n ‚Äì 1 ‚Ä¢ move record n to i ‚Ä¢ do not move records, but link all free records on a free list File Types- Variable-Length Records ÔÉº Field lengths can vary; require special handling: ÔÇß Separator characters (e.g., ?, %, $) between fields ÔÇß Field-name/value pairs for optional fields ÔÇß Field-type/value pairs for efficiency ÔÇß Repeating fields: separators between values, terminator at end ÔÉº Variable-length records arise in database systems in several ways: ‚Ä¢ Storage of multiple record types in a file. ‚Ä¢ Record types that allow variable lengths for one or more fields such as strings (varchar) ‚Ä¢ Record types that allow repeating fields (used in some older data models). ÔÉº Attributes are stored in order ÔÉº Variable length attributes represented by fixed size (offset, length), with actual data stored after all fixed length attributes ÔÉº Null values represented by null-value bitmap File Types- Variable-Length Records Slotted Page Structure Null values represented by null-value bitmap File Types- Variable-Length Records ÔÇß Slotted page header contains: ‚Ä¢ number of record entries ‚Ä¢ end of free space in the block ‚Ä¢ location and size of each record ÔÇß Records can be moved around within a page to keep them contiguous with no empty space between them; entry in the header must be updated. ÔÇß Pointers should not point directly to record ‚Äî instead they should point to the entry for the record in header. File Types- Three record storage formats. Three record storage formats. (a) A fixed-length record with six fields and size of 71 bytes. (b) A record withtwo variable-length fields and three fixed-length fields. (c) A variable-field record with three types of separatorcharacters. Record Blocking and Spanned vs Unspanned Records Disk Storage and File Organization ÔÉº Disk blocks are the unit of data transfer between disk and memory. ÔÉº Each block can store multiple records if the block size (B) > record size (R). ÔÉº Blocking factor (bfr): number of records per block ÔÉº Unused space per block: Record Blocking and Spanned vs Unspanned Records Spanned Records : ÔÉº Part of a record can be stored on one block and the rest on another. ÔÉº Requires a pointer to the next block containing the remainder. ÔÉº Advantages: ÔÇß Utilizes unused space efficiently ÔÇß Useful for records larger than a block ÔÉº Applicable to: Fixed-length or variable-length records when record size > block size Record Blocking and Spanned vs Unspanned Records UnSpanned Records : ÔÉº Records cannot cross block boundaries.. ÔÉº Requires a pointer to the next block containing the remainder. ÔÉº Advantages: ‚Ä¢ Each record starts at a known position within a block ‚Ä¢ Simplifies record processing ÔÉº Applicable to: Fixed-length records where block size > record size Record Blocking and Spanned vs Unspanned Records Choosing Between Spanned and Unspanned Organization Type Pros Cons Use Case Spanned Efficient space usage More complex processing Large or variable- length records Unspanned Simple processing Wasted space in partially filled blocks Fixed-length small records File Block Allocation Techniques Efficiently store file blocks on disk for fast access and expansion. Common techniques: 1. Contiguous Allocation ÔÉº Blocks stored in consecutive disk locations ÔÉº Pros: Fast sequential read (double buffering) ÔÉº Cons: Difficult to expand file 2. Linked Allocation ÔÉº Each block contains a pointer to the next block ÔÉº Pros: Easy to expand file ÔÉº Cons: Slow sequential read File Block Allocation Techniques 3. Combined/Clustered Allocation o Groups of consecutive blocks (clusters) are linked o Clusters also called file segments or extents 4. Indexed Allocation o One or more index blocks store pointers to file blocks o Often combined with other techniques File Headers ‚Ä¢ Metadata about the file needed for access. ‚Ä¢ Contents of a file header: ÔÉò Disk addresses of file blocks ÔÉò Record format description ‚Ä¢ Fixed-length unspanned records: field lengths & field order ‚Ä¢ Variable-length records: field-type codes, separator characters, record type codes ‚Ä¢ Programs use header information to locate and read records efficiently. Searching Records Using File Headers ‚Ä¢ When searching for a record: ÔÉò Copy one or more blocks into main memory buffers ÔÉò Use file header info to identify record location ‚Ä¢ Without block address info: linear search through all blocks is needed ÔÉò Time-consuming for large fisles ‚Ä¢ Goal of file organization: Avoid linear search and minimize full file scans Operations on Files Two main categories: 1. Retrieval operations: Locate records without changing data. 2. Update operations: Change data by inserting, deleting, or modifying records. ‚Ä¢ Selection condition (filtering) used to locate records: ‚Ä¢ Example: (Ssn = '123456789') or (Salary >= 30000 AND Department = 'Research') ‚Ä¢ Complex conditions are decomposed into simple conditions for locating records. Record-at-a-Time Operations Operations applied to a single record rather than multiple records simultaneously. ‚Ä¢ Open: Prepare file for access, allocate buffers, read file header. ‚Ä¢ Reset: Move file pointer to beginning. ‚Ä¢ Find / Locate: Search for first record satisfying condition, load block into buffer. ‚Ä¢ Read / Get: Copy current record into program variable, may advance pointer. ‚Ä¢ FindNext: Locate next record satisfying condition. ‚Ä¢ Delete: Remove current record from file. ‚Ä¢ Modify: Change fields of current record. ‚Ä¢ Insert: Add new record into file block and update disk. ‚Ä¢ Close: Release buffers and complete file access. Scan Operation and Set-at-a- Time Operations Scan Operation ‚Ä¢ Combines Find, FindNext, and Read into a single operation. ‚Ä¢ Returns first or next record satisfying a condition. ‚Ä¢ Simplifies sequential access for retrieval operations. Set-at-a-Time Operations Operate on multiple records at once: ‚Ä¢ FindAll: Retrieve all records satisfying a condition. ‚Ä¢ Find n: Retrieve first n records satisfying a condition. ‚Ä¢ FindOrdered: Retrieve records in a specified order. ‚Ä¢ Reorganize: Reorder records (e.g., by sorting) for efficiency. File Organization vs Access Method and Considerations for File Organization ÔÉº File organization: How data is physically stored in records, blocks, and structures. ÔÉº Access method: Set of operations applied to a file (e.g., Find, Scan). ÔÉº Multiple access methods can operate on a single file organization. ÔÉº Indexed access requires an index; not all methods are universally applicable ÔÉò Expected usage patterns influence organization: ÔÉò Static files: mostly read-only, few updates ÔÉò Dynamic files: frequent insert, delete, modify operations ÔÉò Optimizing for common search conditions improves efficiency Organization of Records in Files ÔÇß Heap ‚Äì record can be placed anywhere in the file where there is space ÔÇß Sequential ‚Äì store records in sequential order, based on the value of the search key of each record ÔÇß In a multitable clustering file organization records of several different relations can be stored in the same file ‚Ä¢ Motivation: store related records on the same block to minimize I/O ÔÇß B+-tree file organization ‚Ä¢ Ordered storage even with inserts/deletes ÔÇß Hashing ‚Äì a hash function computed on search key; the result specifies in which block of the file the record should be placed Heap File Organization ‚Ä¢ Heap file = simplest and most basic file organization. ‚Ä¢ Records are stored in the order they are inserted (no sorting). ‚Ä¢ New records are appended to the end of the file. ‚Ä¢ Commonly used for: ÔÇß Collecting and storing records for future use. ÔÇß Supporting secondary indexes for faster access. ÔÇß Easy insertion, but searching and deletion are less efficient. Insertion Very efficient operation: ‚Ä¢ Copy the last disk block into buffer. ‚Ä¢ Add new record into buffer. ‚Ä¢ Write block back to disk. ‚Ä¢ File header keeps address of the last block. ‚Ä¢ Minimal overhead compared to other organizations. Heap File Organization Searching ‚Ä¢ No ordering of records ‚Üí requires linear search. ‚Ä¢ Must scan block by block until condition is met. ‚Ä¢ Average cost: ‚Ä¢ If one record satisfies condition ‚Üí ~b/2 blocks must be checked (where b = number of blocks). ‚Ä¢ If no records (or multiple records) match ‚Üí all b blocks must be scanned. ‚Ä¢ Searching is expensive for large files. Deletion Two main methods: 1. Physical Deletion ÔÇß Find the block, load into buffer, delete record, write back. ÔÇß Leaves unused space in the block. ÔÇß Deleting many records wastes storage space. 2. Logical Deletion (Deletion Marker) ÔÇß Add an extra bit/byte to mark record as deleted. ÔÇß Valid records are those without deletion marker. ÔÇß Both methods require periodic reorganization to reclaim unused space. Heap File Organization Heap File Organization Reorganization ‚Ä¢ Required when many deletions have occurred. ‚Ä¢ Process: ‚Ä¢ Sequentially access all blocks. ‚Ä¢ Pack valid records together, remove deleted ones. ‚Ä¢ Fill blocks to full capacity again. ‚Ä¢ Alternative approach: ‚Ä¢ Reuse deleted record space during new insertions. ‚Ä¢ Requires bookkeeping to track free space. Heap - Record Organization Options Spanned vs. Unspanned Organization: ÔÇß Spanned: Records can span across multiple blocks. ÔÇß Unspanned: Each record fits entirely within a single block. Fixed-Length vs. Variable-Length Records: Fixed: Easier to manage and access. Variable: More flexible, but modification may require deletion + reinsertion. Sorting records: To read in sorted order, file must be copied and sorted. Sorting is expensive for large files ‚Üí external sorting is used. Heap File Organization Relative (Direct) Files ‚Ä¢ Special type of unordered file with fixed-length records + unspanned blocks. ‚Ä¢ Allows direct access to records by position: ‚Ä¢ If file has r records numbered 0‚Ä¶r-1, and block has bfr (blocking factor) records: ‚Ä¢ Record i is located in block i / bfr‚é£ ‚é¶ ‚Ä¢ Position = (i mod bfr) in that block. ‚Ä¢ Provides direct positional access (efficient). ‚Ä¢ Still does not help with conditional searches. ‚Ä¢ Useful for building access paths like indexes. Heap File Organization Need for Free-Space Tracking ‚Ä¢ Since records can go into any available free space, the system must be able to quickly find blocks with enough empty space. ‚Ä¢ If we scan every block to find free space, it becomes very expensive. ‚Ä¢Solution: use a Free-Space Map. Free-Space Map ‚Ä¢ A free-space map is an array with one entry per block in the file. ‚Ä¢ Each entry is only a few bits or a byte, recording the fraction of the block that is free. Example: Using 3 bits per block. Value √∑ 8 gives the fraction of free space. If value = 4, it means half (4/8 = 0.5) of the block is free. Heap File Organization- Free space map ‚Ä¢ Each horizontal bar = one disk block. ‚Ä¢ Blue portion = free space in the block. ‚Ä¢ Grey portion = occupied records. ‚Ä¢ FSM value (on the left) shows what is stored in the free-space map (scaled using few bits). ‚Ä¢ % free (on the right) indicates the actual free space available. Heap File Organization- Free space map Suppose each disk k block has a fixed size, say 8 KB (8192 bytes Free-Space Map (FSM) does not store exact bytes free. Example: if FSM uses 3 bits per block, it can represent values from 0 to 7. Fraction Free=FSM Value /8 If FSM = 2 Fraction Free = 2 √∑ 8 = 0.25 So 25% of block is free. If block size = 8 KB ‚Üí Free space = 0.25 √ó 8192 = 2048 bytes. Similarly, ‚Ä¢ FSM = 0 ‚Üí 0% free ‚Üí Block is full. ‚Ä¢ FSM = 4 ‚Üí 50% free ‚Üí 4 KB free in an 8 KB block. ‚Ä¢ FSM = 6 ‚Üí 75% free ‚Üí 6 KB free in an 8 KB block. ‚Ä¢ FSM = 7 ‚Üí 100% free ‚Üí Entire block is empty. Heap File Organization Second-Level Free-Space Map ‚Ä¢ For very large files, scanning the entire first-level map is still expensive. ‚Ä¢ A second-level map is created, where each entry stores the maximum free space value of a group of first-level entries. ‚Ä¢ Example: ‚Ä¢ Each second-level entry summarizes 4 first-level entries. ‚Ä¢ This allows the system to quickly locate a region where enough free space exists, and then check only a few blocks in detail. Heap File Organization ‚Ä¢ Left side: First-level FSM values (one entry per block, 0‚Äì7 scale). ‚Ä¢ Right side: Second-level FSM entries. Each summarizes 4 blocks by storing the maximum free space value among them. ‚Ä¢ Arrows show how groups of 4 blocks are linked to one second-level entry. This hierarchy lets the system quickly skip over groups of blocks and find a region with enough space for insertion, instead of scanning every block‚Äôs entry. Heap File Organization ¬† Heap File Organization Insertion using the maps (step-by-step) 1.Use second-level to choose a group needing at least bucket 3. 1. Group A has max=4 (‚â•3) ‚Üí eligible 2.Group B has max=7 (‚â•3) ‚Üí also eligible Pick the first eligible group to minimize seek (say Group A, Blocks 1‚Äì4). 2.Scan first-level entries within Group A for the first block with value ‚â• 3: 1.Block1 = 2 2.Block2 = 4 (means ‚â• 4/8 = 50% free ‚Üí ‚â• 4 KB free) Choose Block2. 3.Validate actual free bytes in Block2 (quick header check). 1.Suppose Block2 actually has 4.2 KB free (FSM rounded down to bucket 4). 2.4.2 KB ‚â• 3 KB, so the record fits. 4.Insert record into Block2. 1.New free space in Block2 ‚âà 4.2 ‚àí 3.0 = 1.2 KB. 2.New free fraction ‚âà 1.2/8 = 0.15 ‚Üí new FSM = floor(8 √ó 0.15) = 1. Heap File Organization Update maps 1. First-level: Block2 value goes 4 ‚Üí 1. 2. Second-level Group A becomes max(2,1,1,3) = 3 (was 4 before). (We write the updated entries eventually; it‚Äôs OK if the persisted map lags a bit.) What if a value was stale? Say we had picked Block8 (FSM=5) but it actually had only 2.5 KB free (because the FSM entry wasn‚Äôt updated yet). ‚Ä¢ On validation, we detect 2.5 KB < 3 KB, so we fail the placement, downgrade Block8‚Äôs FSM to the correct bucket (2), and retry: ‚Ä¢ Group B‚Äôs max might still be ‚â•3 (because of other blocks), so we try the next eligible block in that group; otherwise we fall back to Group A. Heap File OrganizationSequential File Organization ÔÇß Suitable for applications that require sequential processing of the entire file ÔÇß The records in the file are ordered by a search-key Sequential File Organization (Cont.) ÔÇß Deletion ‚Äì use pointer chains ÔÇß Insertion ‚Äìlocate the position where the record is to be inserted ‚Ä¢ if there is free space insert there ‚Ä¢ if no free space, insert the record in an overflow block ‚Ä¢ In either case, pointer chain must be updated ‚Ä¢ Need to reorganize the file from time to time to restore sequential order Multitable Clustering File Organization Store several relations in one file using a multitable clustering file organization department instructor multitable clustering of department and instructor Multitable Clustering File Organization (cont.) ÔÇß good for queries involving department ùîö instructor, and for queries involving one single department and its instructors ÔÇß bad for queries involving only department ÔÇß results in variable size records ÔÇß Can add pointer chains to link records of a particular relation Indexing- Basic Concepts ÔÅÆ Indexing mechanisms used to speed up access to desired data. ÔÉò E.g., author catalog in library ÔÅÆ Search Key - attribute to set of attributes used to look up records in a file. ÔÅÆ An index file consists of records (called index entries) of the form ÔÅÆ Index files are typically much smaller than the original file ÔÅÆ Two basic kinds of indices: ÔÉò Ordered indices: search keys are stored in sorted order ÔÉò Hash indices: search keys are distributed uniformly across ‚Äúbuckets‚Äù using a ‚Äúhash function‚Äù. search-key pointer Index Evaluation Metrics ÔÅÆ Access types supported efficiently. ÔÉòrecords with a specified value in the attribute ÔÉòor records with an attribute value falling in a specified range of values. ÔÅÆ Access time ÔÅÆ Insertion time ÔÅÆ Deletion time ÔÅÆ Space overhead Ordered Indices Indexing techniques evaluated on basis of: ÔÅÆ In an ordered index, index entries are stored sorted on the search key value. E.g., author catalog in library. ÔÅÆ Primary index: in a sequentially ordered file, the index whose search key specifies the sequential order of the file. ÔÉòAlso called clustering index- defined on non-key ordering field (multiple records can share value). ÔÉòThe search key of a primary index is usually but not necessarily the primary key. ÔÅÆ Secondary index: an index whose search key specifies an order different from the sequential order of the file. Also called non-clustering index. ÔÅÆ Index-sequential file: ordered sequential file with a primary index. Ordered Indices Indexing techniques evaluated on basis of: ÔÅÆ In an ordered index, index entries are stored sorted on the search key value. E.g., author catalog in library. ÔÅÆ Primary index: in a sequentially ordered file, the index whose search key specifies the sequential order of the file. ÔÉòAlso called clustering index- defined on non-key ordering field (multiple records can share value). ÔÉòThe search key of a primary index is usually but not necessarily the primary key. ÔÅÆ Secondary index: an index whose search key specifies an order different from the sequential order of the file. Also called non-clustering index. ÔÅÆ Index-sequential file: ordered sequential file with a primary index. Dense Index Files ÔÅÆ Dense index ‚Äî Index record appears for every search- key value in the file. Sparse Index Files ÔÅÆ Sparse Index: contains index records for only some search- key values. ÔÉòApplicable when records are sequentially ordered on search-key ÔÅÆ To locate a record with search-key value K we: ÔÉòFind index record with largest search-key value < K ÔÉòSearch file sequentially starting at the record to which the index record points ÔÅÆ Less space and less maintenance overhead for insertions and deletions. ÔÅÆ Generally slower than dense index for locating records. ÔÅÆ Good tradeoff: sparse index with an index entry for every block in file, corresponding to least search-key value in the block. Example of Sparse Index Files Dense vs Sparse Index ‚Ä¢ Dense Index: One entry per record. ‚Ä¢ Sparse Index: One entry per block (Primary Index). ‚Ä¢ Primary Index = Sparse. ‚Ä¢ Advantage: ‚Ä¢ Index file much smaller than data file. ‚Ä¢ Faster binary search. Searching with Primary Index ‚Ä¢Binary search performed on index file (with b blocks).·µ¢ ‚Ä¢Total accesses = log (b ) + 1‚ÇÇ ·µ¢ ‚Ä¢ log (b ) ‚Üí binary search on index file.‚ÇÇ ·µ¢ ‚Ä¢ +1 ‚Üí access data block. ‚Ä¢Example: ‚Ä¢ Data file = 1,000 blocks. ‚Ä¢ Index file = 100 blocks. ‚Ä¢ Binary search index = log (100) ‚âà 7.‚ÇÇ ‚Ä¢ Access data block = 1. ‚Ä¢ Total ‚âà 8 accesses vs 10 on data file. Clustering Index ‚Ä¢ Defined on a non-key ordering field. ‚Ä¢ File = clustered file. ‚Ä¢ Example: Records ordered by Department, but many employees may share same department. ‚Ä¢ Index entry contains: ‚Ä¢ Value of clustering field. ‚Ä¢ Pointer to block containing first occurrence. Primary Index ‚Ä¢ Built on ordering key field of an ordered file. ‚Ä¢ One entry per block. ‚Ä¢ Each entry <K(i), P(i)> contains: ‚Ä¢ K(i): first key (anchor record) in block i. ‚Ä¢ P(i): pointer to block i. ‚Ä¢ Example: ‚Ä¢ <(Aaron, Ed), P(1)> ‚Üí Block 1 ‚Ä¢ <(Adams, John), P(2)> ‚Üí Block 2 Secondary Index ‚Ä¢ Built on a nonordering field (not sorted in file). ‚Ä¢ Separate access path. ‚Ä¢ Can be dense (usually 1 entry per record). ‚Ä¢ More expensive in terms of storage. Multilevel Index ÔÅÆ If primary index does not fit in memory, access becomes expensive. ÔÅÆ To reduce number of disk accesses to index records, treat primary index kept on disk as a sequential file and construct a sparse index on it. ÔÉòouter index ‚Äì a sparse index of primary index ÔÉòinner index ‚Äì the primary index file ÔÅÆ If even outer index is too large to fit in main memory, yet another level of index can be created, and so on. ÔÅÆ Indices at all levels must be updated on insertion or deletion from the file. Multilevel Index (Cont.)Index Update: Deletion ÔÅÆ If deleted record was the only record in the file with its particular search-key value, the search-key is deleted from the index also. ÔÅÆ Single-level index deletion: ÔÉò Dense indices ‚Äì deletion of search-key is similar to file record deletion. ÔÉò Sparse indices ‚Äì if an entry for the search key exists in the index, it is deleted by replacing the entry in the index with the next search- key value in the file (in search-key order). If the next search-key value already has an index entry, the entry is deleted instead of being replaced. Index Update: Insertion ÔÅÆ Single-level index insertion: ÔÉò Perform a lookup using the search-key value appearing in the record to be inserted. ÔÉò Dense indices ‚Äì if the search-key value does not appear in the index, insert it. ÔÉò Sparse indices ‚Äì if index stores an entry for each block of the file, no change needs to be made to the index unless a new block is created. In this case, the first search-key value appearing in the new block is inserted into the index. ÔÅÆ Multilevel insertion (as well as deletion) algorithms are simple extensions of the single-level algorithms Secondary Indices ÔÅÆ Frequently, one wants to find all the records whose values in a certain field (which is not the search- key of the primary index satisfy some condition. ÔÉò Example 1: In the account database stored sequentially by account number, we may want to find all accounts in a particular branch ÔÉò Example 2: as above, but where we want to find all accounts with a specified balance or range of balances ÔÅÆ We can have a secondary index with an index record for each search-key value; index record points to a bucket that contains pointers to all the actual records with that particular search-key value. Secondary Index on balance field of account Primary and Secondary Indices ÔÅÆ Secondary indices have to be dense. ÔÅÆ Indices offer substantial benefits when searching for records. ÔÅÆ When a file is modified, every index on the file must be updated, Updating indices imposes overhead on database modification. ÔÅÆ Sequential scan using primary index is efficient, but a sequential scan using a secondary index is expensive ÔÉò each record access may fetch a new block from disk Binary Search for Disk Files ‚Ä¢ Records in a file are stored across b blocks (numbered 1, 2, ‚Ä¶, b). ‚Ä¢ Records are sorted by their ordering key field. ‚Ä¢ Goal: efficiently search for a record with key K. ‚Ä¢ Disk block addresses are stored in the file header Uses divide and conquer principle: ‚Ä¢ Check middle block. ‚Ä¢ If K is smaller, search left half. ‚Ä¢ If K is larger, search right half. ‚Ä¢ Repeat until found or search space is empty. Linear Search (Traditional Method) ‚Ä¢ Sequentially checks blocks one by one. ‚Ä¢ Average Case: ~b/2 block accesses if record is found. ‚Ä¢ Worst Case: b block accesses if record is not found. ‚Ä¢ Inefficient for large files. Binary Search Approach ‚Ä¢ Works on blocks, not individual records. ‚Ä¢ Uses divide and conquer principle: ‚Ä¢ Check middle block. ‚Ä¢ If K is smaller, search left half. ‚Ä¢ If K is larger, search right half. ‚Ä¢ Repeat until found or search space is empty Algorithm (Binary Search on Blocks) 1.Set low = 1, high = b. 2.While low ‚â§ high: 1. mid = (low + high)/2. 2. Read block[mid]. 3. If K is in block[mid] ‚Üí record found. 4. Else if K < first key of block[mid] ‚Üí set high = mid ‚Äì 1. 5. Else ‚Üí set low = mid + 1. 3.If no match ‚Üí record not found. Binary Search Approach Block No First Record Key Last Record Key 1 1 100 2 101 200 3 201 300 4 301 400 5 401 500 6 501 600 7 601 700 8 701 800 Suppose a file has b = 8 blocks, each containing sorted records by Roll No. We want to search for Roll No = 630. Step 1: Initialization ‚Ä¢ Low = 1, High = 8 Step 2: Midpoint Block ‚Ä¢ Mid = (1+8)/2 = 4.5 ‚âà 4 ‚Ä¢ Block 4 range = 301‚Äì400 ‚Ä¢ Since 630 > 400, search right half ‚Üí Low = 5, High = 8 Step 3: Next Midpoint ‚Ä¢ Mid = (5+8)/2 = 6.5 ‚âà 6 ‚Ä¢ Block 6 range = 501‚Äì600 ‚Ä¢ Since 630 > 600, search right half ‚Üí Low = 7, High = 8 Step 4: Next Midpoint ‚Ä¢ Mid = (7+8)/2 = 7.5 ‚âà 7 ‚Ä¢ Block 7 range = 601‚Äì700 ‚Ä¢ Since 630 lies in 601‚Äì700, target block = 7 Step 5: Search Inside Block ‚Ä¢ Binary search now continues inside block 7. ‚Ä¢ Records in Block 7 are scanned (either sequentially or with binary search, if block itself is indexed). ‚Ä¢ Record 630 is found in Block 7. Analysis of Accesses ‚Ä¢ Blocks checked: Block 4 ‚Üí Block 6 ‚Üí Block 7 ‚Ä¢ Total = log‚ÇÇ(8) = 3 block accesses ‚Ä¢ Much better than Linear Search: ‚Ä¢ Average = 8/2 = 4 accesses ‚Ä¢ Worst case = 8 accesses Performance Comparison ‚Ä¢ Binary Search: ‚Ä¢ Accesses ‚âà log‚ÇÇ(b) blocks. ‚Ä¢ Independent of whether record is found or not. ‚Ä¢ Linear Search: ‚Ä¢ Average: b/2 blocks. ‚Ä¢ Worst: b blocks. ‚Ä¢ Binary search is much faster for large files. Example ‚Ä¢ Suppose file has b = 1024 blocks. ‚Ä¢ Linear search: ~512 accesses (avg). ‚Ä¢ Binary search: log‚ÇÇ(1024) = 10 accesses only.","libVersion":"0.5.0","langs":""}