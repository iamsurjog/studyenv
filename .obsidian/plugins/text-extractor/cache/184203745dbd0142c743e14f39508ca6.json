{"path":"sem5/CN/pdf/Module-3_Deadlock.pdf","text":"Silberschatz, Galvin and Gagne 20028.1Operating System Concepts Chapt er 8: Deadlocks  System Model  Deadlock Characterization  Methods for Handling Deadlocks  Deadlock Prevention  Deadlock Avoidance  Deadlock Detection  Recovery from Deadlock  Combined Approach to Deadlock Handling Silberschatz, Galvin and Gagne 20028.2Operating System Concepts The Deadlock Problem  A set of blocked processes each holding a resource and waiting to acquire a resource held by another process in the set.  Example  System has 2 tape drives.  P1 and P2 each hold one tape drive and each needs another one.  Example  semaphores A and B, initialized to 1 P0 P1 wait (A); wait(B) wait (B); wait(A) Silberschatz, Galvin and Gagne 20028.3Operating System Concepts Bridge Crossing Example  Traffic only in one direction.  Each section of a bridge can be viewed as a resource.  If a deadlock occurs, it can be resolved if one car backs up (preempt resources and rollback).  Several cars may have to be backed up if a deadlock occurs.  Starvation is possible. Silberschatz, Galvin and Gagne 20028.4Operating System Concepts Syst em M odel  Resource types R1, R2, . . ., Rm CPU cycles, memory space, I/O devices  Each resource type Ri has Wi instances.  Each process utilizes a resource as follows:  request  use  release Silberschatz, Galvin and Gagne 20028.5Operating System Concepts Deadlock Charact erizat ion  Mutual exclusion: only one process at a time can use a resource.  Hold and wait: a process holding at least one resource is waiting to acquire additional resources held by other processes.  No preemption: a resource can be released only voluntarily by the process holding it, after that process has completed its task.  Circular wait: there exists a set {P0, P1, …, P0} of waiting processes such that P0 is waiting for a resource that is held by P1, P1 is waiting for a resource that is held by P2, …, Pn–1 is waiting for a resource that is held by Pn, and P0 is waiting for a resource that is held by P0. Deadlock can arise if four conditions hold simultaneously. Silberschatz, Galvin and Gagne 20028.6Operating System Concepts Resource-Allocation Graph  V is partitioned into two types:  P = {P1, P2, …, Pn}, the set consisting of all the processes in the system.  R = {R1, R2, …, Rm}, the set consisting of all resource types in the system.  request edge – directed edge P1  Rj  assignment edge – directed edge Rj  Pi A set of vertices V and a set of edges E. Silberschatz, Galvin and Gagne 20028.7Operating System Concepts Resource-Allocation Graph (Cont.)  Process  Resource Type with 4 instances  Pi requests instance of Rj  Pi is holding an instance of Rj Pi Pi Rj Rj Silberschatz, Galvin and Gagne 20028.8Operating System Concepts Example of a Resource Allocation Graph Silberschatz, Galvin and Gagne 20028.9Operating System Concepts Resource Allocation Graph With A Deadlock Silberschatz, Galvin and Gagne 20028.10Operating System Concepts Resource Allocat ion Graph Wit h A Cycle But No Deadlock Silberschatz, Galvin and Gagne 20028.11Operating System Concepts Basic Facts  If graph contains no cycles  no deadlock.  If graph contains a cycle   if only one instance per resource type, then deadlock.  if several instances per resource type, possibility of deadlock. Silberschatz, Galvin and Gagne 20028.12Operating System Concepts M et hods for Handling Deadlocks  Ensure that the system will never enter a deadlock state.  Allow the system to enter a deadlock state and then recover.  Ignore the problem and pretend that deadlocks never occur in the system; used by most operating systems, including UNIX. Silberschatz, Galvin and Gagne 20028.13Operating System Concepts Deadlock Prevent ion  Mutual Exclusion – not required for sharable resources; must hold for nonsharable resources.  Hold and Wait – must guarantee that whenever a process requests a resource, it does not hold any other resources.  Require process to request and be allocated all its resources before it begins execution, or allow process to request resources only when the process has none.  Low resource utilization; starvation possible. Restrain the ways request can be made. Silberschatz, Galvin and Gagne 20028.14Operating System Concepts Deadlock Prevent ion (Cont.)  No Preemption –  If a process that is holding some resources requests another resource that cannot be immediately allocated to it, then all resources currently being held are released.  Preempted resources are added to the list of resources for which the process is waiting.  Process will be restarted only when it can regain its old resources, as well as the new ones that it is requesting.  Circular Wait – impose a total ordering of all resource types, and require that each process requests resources in an increasing order of enumeration. Silberschatz, Galvin and Gagne 20028.15Operating System Concepts Deadlock Avoidance  Simplest and most useful model requires that each process declare the maximum number of resources of each type that it may need.  The deadlock-avoidance algorithm dynamically examines the resource-allocation state to ensure that there can never be a circular-wait condition.  Resource-allocation state is defined by the number of available and allocated resources, and the maximum demands of the processes. Requires that the system has some additional a priori information available. Silberschatz, Galvin and Gagne 20028.16Operating System Concepts Safe St ate  When a process requests an available resource, system must decide if immediate allocation leaves the system in a safe state.  System is in safe state if there exists a safe sequence of all processes.  Sequence <P1, P2, …, Pn> is safe if for each Pi, the resources that Pi can still request can be satisfied by currently available resources + resources held by all the Pj, with j<I.  If Pi resource needs are not immediately available, then Pi can wait until all Pj have finished.  When Pj is finished, Pi can obtain needed resources, execute, return allocated resources, and terminate.  When Pi terminates, Pi+1 can obtain its needed resources, and so on. Silberschatz, Galvin and Gagne 20028.17Operating System Concepts Basic Facts  If a system is in safe state  no deadlocks.  If a system is in unsafe state  possibility of deadlock.  Avoidance  ensure that a system will never enter an unsafe state. Silberschatz, Galvin and Gagne 20028.18Operating System Concepts Safe, Unsafe , Deadlock Stat e Silberschatz, Galvin and Gagne 20028.19Operating System Concepts Resource-Allocation Graph Algorithm  Claim edge Pi  Rj indicated that process Pi may request resource Rj; represented by a dashed line.  Claim edge converts to request edge when a process requests a resource.  When a resource is released by a process, assignment edge reconverts to a claim edge.  Resources must be claimed a priori in the system. Silberschatz, Galvin and Gagne 20028.20Operating System Concepts Resource-Allocat ion Graph For Deadlock Avoidance Silberschatz, Galvin and Gagne 20028.21Operating System Concepts Unsafe State I n Resource-Allocation Graph Silberschatz, Galvin and Gagne 20028.22Operating System Concepts Banker’s Algorit hm  Multiple instances.  Each process must provide a priori claim for maximum use.  When a process requests a resource, it may have to wait.  When a process gets all its resources, it must return them in a finite amount of time. Silberschatz, Galvin and Gagne 20028.23Operating System Concepts Data Structures for the Banker’s Algorithm  Available: Vector of length m. If available [j] = k, there are k instances of resource type Rj available.  Max: n x m matrix. If Max [i,j] = k, then process Pi may request at most k instances of resource type Rj.  Allocation: n x m matrix. If Allocation[i,j] = k then Pi is currently allocated k instances of Rj.  Need: n x m matrix. If Need[i,j] = k, then Pi may need k more instances of Rj to complete its task. Need [i,j] = Max[i,j] – Allocation [i,j]. Let n = number of processes, and m = number of resources types. Silberschatz, Galvin and Gagne 20028.24Operating System Concepts Safety Algorit hm 1. Let Work and Finish be vectors of length m and n, respectively. Initialize: Work = Available Finish [i] = false for i = 1,2, 3, …, n. 2. Find an i such that both: (a) Finish [i] = false (b) Needi  Work If no such i exists, go to step 4. 3. Work = Work + Allocationi Finish[i] = true go to step 2. 4. If Finish [i] == true for all i, then the system is in a safe state. Silberschatz, Galvin and Gagne 20028.25Operating System Concepts Resource-Request Algorithm for Process Pi Request = request vector for process Pi. If Request i [j] = k then process Pi wants k instances of resource type Rj. 1. If Request i  Needi go to step 2. Otherwise, raise error condition, since process has exceeded its m axim um claim . 2. If Request i  Available, go to step 3. Otherwise Pi m ust wait, since resources are not available. 3. Pretend to allocate requested resources to Pi by m odifying the state as follows: Available = Available - Request i; Allocationi = Allocationi + Request i; Needi = Needi – Request i;; • If safe  the resources are allocated to Pi. • If unsafe  Pi must wait, and the old resource-allocation state is restored Silberschatz, Galvin and Gagne 20028.26Operating System Concepts Example of Banker’s Algorit hm  5 processes P0 through P4; 3 resource types A (10 instances), B (5instances, and C (7 instances).  Snapshot at time T0: Allocation Max Available A B C A B C A B C P0 0 1 0 7 5 3 3 3 2 P1 2 0 0 3 2 2 P2 3 0 2 9 0 2 P3 2 1 1 2 2 2 P4 0 0 2 4 3 3 Silberschatz, Galvin and Gagne 20028.27Operating System Concepts Example (Cont.)  The content of the matrix. Need is defined to be Max – Allocation. Need A B C P0 7 4 3 P1 1 2 2 P2 6 0 0 P3 0 1 1 P4 4 3 1  The system is in a safe state since the sequence < P1, P3, P4, P2, P0> satisfies safety criteria. Silberschatz, Galvin and Gagne 20028.28Operating System Concepts Example P1 Request (1,0,2) (Cont .)  Check that Request  Available (that is, (1,0,2)  (3,3,2)  true. Allocation Need Available A B C A B C A B C P0 0 1 0 7 4 3 2 3 0 P1 3 0 2 0 2 0 P2 3 0 1 6 0 0 P3 2 1 1 0 1 1 P4 0 0 2 4 3 1  Executing safety algorithm shows that sequence <P1, P3, P4, P0, P2> satisfies safety requirem ent.  Can request for (3,3,0) by P4 be granted?  Can request for (0,2,0) by P0 be granted? Silberschatz, Galvin and Gagne 20028.29Operating System Concepts Deadlock Det ect ion  Allow system to enter deadlock state  Detection algorithm  Recovery schem e Silberschatz, Galvin and Gagne 20028.30Operating System Concepts Single I nstance of Each Resource Type  Maintain wait-for graph  Nodes are processes.  Pi  Pj if Pi is waiting for Pj.  Periodically invoke an algorithm that searches for a cycle in the graph.  An algorithm to detect a cycle in a graph requires an order of n2 operations, where n is the num ber of vertices in the graph. Silberschatz, Galvin and Gagne 20028.31Operating System Concepts Resource-Allocat ion Graph and Wait -for Graph Resource-Allocation Graph Corresponding wait-for graph Silberschatz, Galvin and Gagne 20028.32Operating System Concepts Several I nst ances of a Resource Type  Available: A vector of length m indicates the num ber of available resources of each type.  Allocation: An n x m m atrix defines the num ber of resources of each type currently allocated to each process.  Request: An n x m m atrix indicates the current request of each process. If Request [ij] = k, then process Pi is requesting k m ore instances of resource type. Rj. Silberschatz, Galvin and Gagne 20028.33Operating System Concepts Detect ion Algorithm 1. Let Work and Finish be vectors of length m and n, respectively Initialize: (a) Work = Available (b) For i = 1,2, …, n, if Allocationi  0, then Finish[i] = false;otherwise, Finish[i] = true. 2. Find an index i such that both: (a) Finish[i] == false (b) Requesti  Work If no such i exists, go to step 4. Silberschatz, Galvin and Gagne 20028.34Operating System Concepts Detect ion Algorithm (Cont.) 3. Work = Work + Allocationi Finish[i] = true go to step 2. 4. If Finish[i] == false, for som e i, 1  i  n, then the system is in deadlock state. Moreover, if Finish[i] == false, then Pi is deadlocked. Algorithm requires an order of O(m x n2) operations to detect whether the system is in deadlocked state. Silberschatz, Galvin and Gagne 20028.35Operating System Concepts Example of Detect ion Algorithm  Five processes P0 through P4; three resource types A (7 instances), B (2 instances), and C (6 instances).  Snapshot at tim e T0: Allocation Request Available A B C A B C A B C P0 0 1 0 0 0 0 0 0 0 P1 2 0 0 2 0 2 P2 3 0 3 0 0 0 P3 2 1 1 1 0 0 P4 0 0 2 0 0 2  Sequence <P0, P2, P3, P1, P4> will result in Finish[i] = true for all i. Silberschatz, Galvin and Gagne 20028.36Operating System Concepts Example (Cont.)  P2 requests an additional instance of type C. Request A B C P0 0 0 0 P1 2 0 1 P2 0 0 1 P3 1 0 0 P4 0 0 2  State of system ?  Can reclaim resources held by process P0, but insufficient resources to fulfill other processes; requests.  Deadlock exists, consisting of processes P1, P2, P3, and P4. Silberschatz, Galvin and Gagne 20028.37Operating System Concepts Detect ion-Algorithm Usage  When, and how often, to invoke depends on:  How often a deadlock is likely to occur?  How m any processes will need to be rolled back?  one for each disjoint cycle  If detection algorithm is invoked arbitrarily, there m ay be m any cycles in the resource graph and so we would not be able to tell which of the m any deadlocked processes “caused” the deadlock. Silberschatz, Galvin and Gagne 20028.38Operating System Concepts Recovery from Deadlock: Process Termination  Abort all deadlocked processes.  Abort one process at a tim e until the deadlock cycle is elim inated.  In which order should we choose to abort?  Priority of the process.  How long process has computed, and how much longer to com pletion.  Resources the process has used.  Resources process needs to com plete.  How m any processes will need to be term inated.  Is process interactive or batch? Silberschatz, Galvin and Gagne 20028.39Operating System Concepts Recovery from Deadlock: Resource Preempt ion  Selecting a victim – m inim ize cost.  Rollback – return to som e safe state, restart process for that state.  Starvation – sam e process m ay always be picked as victim , include num ber of rollback in cost factor. Silberschatz, Galvin and Gagne 20028.40Operating System Concepts Combined Approach to Deadlock Handling  Com bine the three basic approaches  prevention  avoidance  detection allowing the use of the optim al approach for each of resources in the system .  Partition resources into hierarchically ordered classes.  Use m ost appropriate technique for handling deadlocks within each class. Silberschatz, Galvin and Gagne 20028.41Operating System Concepts Traffic Deadlock for Exercise 8.4","libVersion":"0.5.0","langs":""}