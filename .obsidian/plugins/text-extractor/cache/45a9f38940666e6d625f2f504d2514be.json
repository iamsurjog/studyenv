{"path":"sem5/CN/pdf/Module-5_Demand Paging-Page replacement algorithms.pdf","text":"Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Virtual Memory 10.2 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Background  Code needs to be in memory to execute, but entire program rarely used • Error code, unusual routines, large data structures  Entire program code not needed at same time  Consider ability to execute partially-loaded program • Program no longer constrained by limits of physical memory • Each program takes less memory while running -> more programs run at the same time  Increased CPU utilization and throughput with no increase in response time or turnaround time • Less I/O needed to load or swap programs into memory -> each user program runs faster 10.3 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Virtual memory  Virtual memory – separation of user logical memory from physical memory • Only part of the program needs to be in memory for execution • Logical address space can therefore be much larger than physical address space • Allows address spaces to be shared by several processes • Allows for more efficient process creation • More programs running concurrently • Less I/O needed to load or swap processes 10.4 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Virtual memory (Cont.)  Virtual address space – logical view of how process is stored in memory • Usually start at address 0, contiguous addresses until end of space • Meanwhile, physical memory organized in page frames • MMU must map logical to physical  Virtual memory can be implemented via: • Demand paging • Demand segmentation 10.5 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Virtual Memory That is Larger Than Physical Memory 10.6 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Demand Paging  Could bring entire process into memory at load time  Or bring a page into memory only when it is needed • Less I/O needed, no unnecessary I/O • Less memory needed • Faster response • More users  Similar to paging system with swapping (diagram on right)  invalid reference  abort • Not-in-memory  bring to memory  Lazy swapper – never swaps a page into memory unless page will be needed • Swapper that deals with pages is a pager 10.7 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Basic Concepts  With swapping, the pager guesses which pages will be used before swapping them out again  How to determine that set of pages?  Need new MMU functionality to implement demand paging  If pages needed are already memory resident • No difference from non demand-paging  If page needed and not memory resident • Need to detect and load the page into memory from storage  Without changing program behavior  Without programmer needing to change code  Use page table with valid-invalid bit 10.8 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Page table with Valid-Invalid Bit  With each page table entry a valid–invalid bit is associated (v  in-memory, i  not-in-memory)  Initially valid–invalid bit is set to i on all entries  Example of a page table snapshot:  During MMU address translation, if valid–invalid bit in the page table entry is i  page fault 10.9 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Page Table When Some Pages Are Not in Main Memory 10.10 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Steps in Handling Page Fault 1. If there is a reference to a page, first reference to that page will trap to operating system • Page fault 2. Operating system looks at another table to decide: • Invalid reference  abort • Just not in memory (go to step 3) 3. Find free frame (what if there is none?) 4. Swap page into frame via scheduled disk operation 5. Reset tables to indicate page now in memory Set validation bit = v 6. Restart the instruction that caused the page fault 10.11 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Steps in Handling a Page Fault (Cont.) 10.12 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Aspects of Demand Paging  Pure demand paging: start process with no pages in memory • OS sets instruction pointer to first instruction of process, non-memory-resident -> page fault • And for every other process pages on first access  Actually, a given instruction could access multiple pages -> multiple page faults • Consider fetch and decode of instruction which adds 2 numbers from memory and stores result back to memory  Hardware support needed for demand paging • Page table with valid / invalid bit • Secondary memory (swap device with swap space) • Instruction restart 10.13 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Instruction Restart  Consider an instruction that could access several different locations • Block move • Auto increment/decrement location • Restart the whole operation?  What if source and destination overlap? 10.14 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Free-Frame List  When a page fault occurs, the operating system must bring the desired page from secondary storage into main memory.  Most operating systems maintain a free-frame list -- a pool of free frames for satisfying such requests.  Operating system typically allocate free frames using a technique known as zero-fill-on-demand -- the content of the frames zeroed-out before being allocated.  When a system starts up, all available memory is placed on the free-frame list. 10.15 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Stages in Demand Paging – Worse Case 1. Trap to the operating system 2. Save the user registers and process state 3. Determine that the interrupt was a page fault 4. Check that the page reference was legal and determine the location of the page on the disk 5. Issue a read from the disk to a free frame: a) Wait in a queue for this device until the read request is serviced b) Wait for the device seek and/or latency time c) Begin the transfer of the page to a free frame 10.16 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Stages in Demand Paging (Cont.) 6. While waiting, allocate the CPU to some other user 7. Receive an interrupt from the disk I/O subsystem (I/O completed) 8. Save the registers and process state for the other user 9. Determine that the interrupt was from the disk 10. Correct the page table and other tables to show page is now in memory 11. Wait for the CPU to be allocated to this process again 12. Restore the user registers, process state, and new page table, and then resume the interrupted instruction 10.17 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Performance of Demand Paging  Three major activities • Service the interrupt – careful coding means just several hundred instructions needed • Input the page from disk – lots of time • Restart the process – again just a small amount of time  Page Fault Rate 0  p  1 • if p = 0 no page faults • if p = 1, every reference is a fault  Effective Access Time (EAT) EAT = (1 – p) x memory access + p (page fault overhead + swap page out + swap page in ) 10.18 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Demand Paging Example  Memory access time = 200 nanoseconds  Average page-fault service time = 8 milliseconds  EAT = (1 – p) x 200 + p (8 milliseconds) = (1 – p) x 200 + p x 8,000,000 = 200 + p x 7,999,800  If one access out of 1,000 causes a page fault, then EAT = 8.2 microseconds. This is a slowdown by a factor of 40!!  If want performance degradation < 10 percent • 220 > 200 + 7,999,800 x p 20 > 7,999,800 x p • p < .0000025  one page fault in every 400,000 memory accesses 10.19 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Copy-on-Write  Copy-on-Write (COW) allows both parent and child processes to initially share the same pages in memory • If either process modifies a shared page, only then is the page copied  COW allows more efficient process creation as only modified pages are copied  In general, free pages are allocated from a pool of zero-fill-on-demand pages • Pool should always have free frames for fast demand page execution  Don’t want to have to free a frame as well as other processing on page fault • Why zero-out a page before allocating it?  vfork() variation on fork() system call has parent suspend and child using copy-on-write address space of parent • Designed to have child call exec() • Very efficient 10.20 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition What Happens if There is no Free Frame?  Used up by process pages  Also in demand from the kernel, I/O buffers, etc  How much to allocate to each?  Page replacement – find some page in memory, but not really in use, page it out • Algorithm – terminate? swap out? replace the page? • Performance – want an algorithm which will result in minimum number of page faults  Same page may be brought into memory several times 10.21 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Page Replacement  Prevent over-allocation of memory by modifying page-fault service routine to include page replacement  Use modify (dirty) bit to reduce overhead of page transfers – only modified pages are written to disk  Page replacement completes separation between logical memory and physical memory – large virtual memory can be provided on a smaller physical memory 10.22 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Need For Page Replacement 10.23 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Basic Page Replacement 1. Find the location of the desired page on disk 2. Find a free frame: - If there is a free frame, use it - If there is no free frame, use a page replacement algorithm to select a victim frame - Write victim frame to disk if dirty 3. Bring the desired page into the (newly) free frame; update the page and frame tables 4. Continue the process by restarting the instruction that caused the trap Note now potentially 2 page transfers for page fault – increasing EAT 10.24 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Page Replacement 10.25 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Page and Frame Replacement Algorithms  Frame-allocation algorithm determines • How many frames to give each process • Which frames to replace  Page-replacement algorithm • Want lowest page-fault rate on both first access and re-access  Evaluate algorithm by running it on a particular string of memory references (reference string) and computing the number of page faults on that string • String is just page numbers, not full addresses • Repeated access to the same page does not cause a page fault • Results depend on number of frames available  In all our examples, the reference string of referenced page numbers is 7,0,1,2,0,3,0,4,2,3,0,3,0,3,2,1,2,0,1,7,0,1 10.26 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Graph of Page Faults Versus the Number of Frames 10.27 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition First-In-First-Out (FIFO) Algorithm  Reference string: 7,0,1,2,0,3,0,4,2,3,0,3,0,3,2,1,2,0,1,7,0,1  3 frames (3 pages can be in memory at a time per process)  How to track ages of pages? • Just use a FIFO queue 15 page faults 10.28 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Belady’s Anomaly  Consider the string 1,2,3,4,1,2,5,1,2,3,4,5 • Adding more frames can cause more page faults!  Graph illustrating Belady’s Anomaly 10.29 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Optimal Algorithm  Replace page that will not be used for longest period of time • 9 is optimal for the example  How do you know this? • Can’t read the future  Used for measuring how well your algorithm performs  Optimal is an example of stack algorithms that don’t suffer from Belady’s Anomaly 10.30 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Least Recently Used (LRU) Algorithm  Use past knowledge rather than future  Replace page that has not been used in the most amount of time  Associate time of last use with each page  12 faults – better than FIFO but worse than OPT  Generally good algorithm and frequently used  LRU is another example of stack algorithms; thus it does not suffer from Belady’s Anomaly 10.31 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition LRU Algorithm Implementation  Time-counter implementation • Every page entry has a time-counter variable; every time a page is referenced through this entry, copy the value of the clock into the time-counter • When a page needs to be changed, look at the time-counters to find smallest value  Search through a table is needed  Stack implementation • Keep a stack of page numbers in a double link form: • Page referenced:  Move it to the top  Requires 6 pointers to be changed • But each update more expensive • No search for replacement 10.32 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Stack Implementation  Use of a stack to record most recent page references 10.33 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition LRU Approximation Algorithms  Needs special hardware  Reference bit • With each page associate a bit, initially = 0 • When page is referenced bit set to 1  Replace any with reference bit = 0 (if one exists) • We do not know the order, however 10.34 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition LRU Approximation Algorithms (cont.)  Second-chance algorithm • Generally FIFO, plus hardware-provided reference bit  Clock replacement • If page to be replaced has  Reference bit = 0 -> replace it  Reference bit = 1 then: – Set reference bit 0, leave page in memory – Replace next page, subject to same rules 10.35 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Second-chance Algorithm 10.36 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Enhanced Second-Chance Algorithm  Improve algorithm by using reference bit and modify bit (if available) in concert  Take ordered pair (reference, modify): • (0, 0) neither recently used not modified – best page to replace • (0, 1) not recently used but modified – not quite as good, must write out before replacement • (1, 0) recently used but clean – probably will be used again soon • (1, 1) recently used and modified – probably will be used again soon and need to write out before replacement  When page replacement called for, use the clock scheme but use the four classes replace page in lowest non-empty class • Might need to search circular queue several times 10.37 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Counting Algorithms  Keep a counter of the number of references that have been made to each page • Not common  Lease Frequently Used (LFU) Algorithm: • Replaces page with smallest count  Most Frequently Used (MFU) Algorithm: • Based on the argument that the page with the smallest count was probably just brought in and has yet to be used 10.38 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Page-Buffering Algorithms  Keep a pool of free frames, always • Then frame available when needed, not found at fault time • Read page into free frame and select victim to evict and add to free pool • When convenient, evict victim  Possibly, keep list of modified pages • When backing store otherwise idle, write pages there and set to non-dirty  Possibly, keep free frame contents intact and note what is in them • If referenced again before reused, no need to load contents again from disk • Generally useful to reduce penalty if wrong victim frame selected 10.39 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Page-Buffering Algorithms  Keep a pool of free frames which is never empty • Thus a frame is available when needed, not found at fault time • Read page into free frame and select victim to evict and add to free pool • When convenient, evict victim  Possibly, keep list of modified pages • When backing store otherwise idle, write pages there and set to non-dirty  Possibly, keep free frame contents intact and note what is in them • If referenced again before reused, no need to load contents again from disk • Generally useful to reduce penalty if wrong victim frame selected 10.40 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Applications and Page Replacement  All of these algorithms have OS guessing about future page access  Some applications have better knowledge – i.e., databases  Memory intensive applications can cause double buffering • OS keeps copy of page in memory as I/O buffer • Application keeps page in memory for its own work  Operating system can provide direct access to the disk, getting out of the way of the applications • Raw disk mode  Bypasses buffering, locking, etc. 10.41 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Allocation of Frames  Each process needs minimum number of frames  Example: IBM 370 – 6 pages to handle SS MOVE instruction: • Instruction is 6 bytes, might span 2 pages • 2 pages to handle from • 2 pages to handle to  Maximum of course is total frames in the system  Two major allocation schemes • Fixed allocation • Priority allocation  Many variations 10.42 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Fixed Allocation  Equal allocation – For example, if there are 100 frames (after allocating frames for the OS) and 5 processes, give each process 20 frames • Keep some as free frame buffer pool  Proportional allocation – Allocate according to the size of process • Dynamic as degree of multiprogramming, process sizes change m S s pa m sS ps i ii i ii     for allocation frames of number total process of size 10.43 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Global vs. Local Allocation  Global replacement – process selects a replacement frame from the set of all frames; one process can take a frame from another • Process execution time can vary greatly • Greater throughput so more commonly used  Local replacement – each process selects from only its own set of allocated frames • More consistent per-process performance • But possibly underutilized memory • What if a process does not have enough frames? 10.44 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Non-Uniform Memory Access  So far, we assumed that all memory accessed equally  Many systems are NUMA – speed of access to memory varies • Consider system boards containing CPUs and memory, interconnected over a system bus  NUMA multiprocessing architecture 10.45 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition NUMA Access (Cont.)  Optimal performance comes from allocating memory “close to” the CPU on which the thread is scheduled • And modifying the scheduler to schedule the thread on the same system board when possible • Solved by Solaris by creating lgroups  Structure to track CPU / Memory low latency groups  Used my schedule and pager  When possible schedule all threads of a process and allocate all memory for that process within the lgroup 10.46 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Thrashing  If a process does not have “enough” pages, the page-fault rate is very high • Page fault to get page • Replace existing frame • But quickly need the replaced frame back  This leads to: • Low CPU utilization • Operating system thinking that it needs to increase the degree of multiprogramming • Another process added to the system 10.47 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Thrashing (Cont.)  Thrashing. A process is busy swapping pages in and out 10.48 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Demand Paging and Thrashing  Why does demand paging work? Locality model • Process migrates from one locality to another • Localities may overlap  Why does thrashing occur?  size of locality > total memory size  To avoid trashing: • Calculate the  size of locality • Policy:  if  size of locality > total memory size suspend or swap out one of the processes  Issue: how to calculate “ size of locality” 10.49 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Locality In A Memory-Reference Pattern 10.50 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Working-Set Model    working-set window  a fixed number of page references Example: 10,000 instructions  WSSi (working set of Process Pi) = total number of pages referenced in the most recent  (varies in time) • if  too small will not encompass the entire locality • if  too large will encompass several localities • if  =   will encompass entire program  Example 10.51 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Working-Set Model    working-set window  a fixed number of page references Example: 10,000 instructions  WSSi (working set of Process Pi) = total number of pages referenced in the most recent  (varies in time) • if  too small will not encompass the entire locality • if  too large will encompass several localities • if  =   will encompass entire program  D =  WSSi  total demand frames • Approximation of locality 10.52 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Working Sets and Page Fault Rates  Direct relationship between working set of a process and its page-fault rate  Working set changes over time  Peaks and valleys over time 10.53 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Page-Fault Frequency Algorithm  More direct approach than WSS  Establish “acceptable” page-fault frequency (PFF) rate and use local replacement policy • If actual rate too low, process loses frame • If actual rate too high, process gains frame","libVersion":"0.5.0","langs":""}