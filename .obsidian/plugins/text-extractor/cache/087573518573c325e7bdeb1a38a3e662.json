{"path":"sem5/CD/Module 1_16.07.2025.pdf","text":"BCSE307L – COMPILER DESIGN 12345 Language Processors ❑Compiler ❑Interpreter 6 Introduction to Compiler Compiler  A compiler is a program takes a program written in a source language and translates it into an equivalent program in a target language. source program COMPILER target program error messages 7 Compiler Compilers: Translate a source (human-writable) program to an executable (machine-readable) program Example: FORTRAN, COBOL, C, C++, Pascal Compiler Executable / Target Program Source code Executable / Target Program Input data Output data 8 Interpreter An Interpreter Run programs “as is” without preliminary translation: Successive phases of translation (to machine/intermediate code) and execution. Interpreters: Convert a source program and execute it at the same time.(Line by line execution) Example: Lisp, BASIC, APL, Perl, Python Interpreter Source code Input data Output data 910 Compiler VS. Interpreter Compiler – Efficient for production applications – Order of magnitude faster Interpreter – Efficient and rapid for prototyping – Efficient error reporting Compiler vs. Interpreter Compilers: Translate a source (human-writable) program to an executable (machine-readable) program Interpreters: Convert a source program and execute it at the same time.(Line by line execution) Hybrid Compiler ◦ Virtual Machines (e.g., Java) ◦ Linking executable at runtime ◦ Java compiler (Just-in-time compiler) Translator Virtual machine Source code Intermediate program Intermediate program Input Data Output 12 Types of Compiler Cross- Compiler-runs on a Windows 7 PC but generates code that runs on Android smartphone . De-Compiler ◦ LL to HLL Tanscompiler / Source-Source compiler ◦Pascal to C Incremental Compiler ◦ Recompile only the portions modified 13 The Structure of a Compiler ◦ Lexical Analyzer ◦ Syntax Analyzer ◦ Semantic Analyzer ◦ Intermediate Code Generator ◦ Machine –Independent Code Optimizer ◦ Code Generator ◦ Machine – Dependent Code Optimizer 14 Phases of Compiler 15 The Structure of a Compiler / Phases of Compiler ◦ Lexical Analyzer ◦ Syntax Analyzer ◦ Semantic Analyzer ◦ Intermediate Code Generator ◦ Code Optimizer ◦ Code Generator 16 Phases of a Compiler 17 Major Parts of Compiler Operation Compiler consists of two Parts ❑Analysis : Breaks the source program into constituent pieces and creates intermediate representation. The analysis part can be divided into: ➢Lexical Analysis / Linear analysis / Scanning ➢Syntax Analysis / Hierarchical analysis ➢Semantic Analysis / Type checker ➢Intermediate Code Generator Analysis (Front End) Synthesis (Back End) 18 ❑Synthesis : Generates the target program from the intermediate representation. The synthesis part can be divided along the following phases: ➢Code Optimizer ➢Code Generator 19 ➢ The Lexical Analyzer reads the program from left-to-right and sequence of characters are grouped into tokens–lexical units with a collective meaning. ➢The sequence of characters that gives rise to a token is called lexeme. < token-name, attribute-value > Lexical Analysis Input : position = initial + rate * 60 Then, the lexical analyzer will group the characters in the following tokens: 20 Lexical Analysis 21 Lexical Analysis < id , 1> < = > <id, 2> < + > < id , 3 > < * > < 60 > Output: id1 = id2 + id3 * 60 22 Lexical Analysis • Stream of characters is grouped into tokens • Examples of tokens are identifiers, reserved words, integers, doubles or floats, delimiters, operators and special symbols int a; a = a + 2; 23 Lexical Analysis int Keyword a identifier ; special symbol a identifier = operator a identifier + operator 2 integer constant ; special symbol 24 Syntax Analysis ➢The Syntactic Analysis is also called Parsing. ➢(Determination of structure of source string) ➢Tokens are grouped into grammatical phrases represented by a Parse Tree which gives a hierarchical structure to the source program. 25 Parse Tree : Syntax Analysis 26 Syntax Tree : Syntax Analysis 27 ➢ The Semantic Analysis – Determination of meaning of source program ➢Checks the program for semantic errors (Type Checking) and gathers type information for the successive phases. ➢ Type Checking: Compiler checks that each operator has matching operands Semantic Analysis 28 Type Conversion (coercions) ◦ Eg: binary operator applied to either pair of integer or floating point ◦ Compiler may convert or coerce the integer into a floating point Semantic Analysis 29 Abstract Syntax Tree : Semantic Analysis 30 • The intermediate code should be easy to translate into the target program. • Typical choices of intermediate code representation: – Annotated parse trees – Three Address Code (TAC) – Post fix – Bytecode, as in Java bytecode. Intermediate Code Generation 31 Intermediate Code Generation ❑Three-address code: Sequence of instructions with at most three operands such that: ➢ There is at most one operator, in addition to the assignment. ➢ Temporary names must be generated to compute intermediate operations. Output: t1 = inttofloat(60) t2 = id3 * t1 t3 = id2 + t2 id1 = t3 32 Intermediate Code Generation Another example: Input: if (a <= b) { a = a – c; } c = b * c Resulting TAC: t1 = a <= b if t1 goto L0 t2 = a – c a = t2 L0: t3 = b * c C = t3 33 Code Optimization • Compiler converts the intermediate representation to another one that attempts to be smaller and faster. • Typical optimizations: – Inhibit code generation for unreachable segments – Getting rid of unused variables – Eliminating multiplication by 1 and addition by 0 – Loop optimization: e.g. removing statements not modified in the loop – Common sub-expression elimination 34 Code Optimization Output: t1 = id3 * 60.0 t2 = id2 + t1 id1 = t2 35 ➢This phase generates the target code consisting of assembly code. 1. Memory locations are selected for each variable 2. Instructions are translated into a sequence of assembly instructions 3. Variables and intermediate results are assigned to memory registers Code Generation 36 Output: LDF R2 , id3 MULF R2 , R2 , #60.0 LDF R1 , id2 ADDF R1 , R1 , R2 STF id1 , R1 Code Generation 37 ➢ An essential function of a compiler is to build the Symbol Table where the identifiers used in the program are recorded along with various Attributes. – Identifiers are found in lexical analysis and placed in the symbol table – During syntactical and semantical analysis, type and scope information are added – During code generation, type information is used to determine what instructions to use – During optimization, the “live analysis” may be kept in the symbol table Symbol Table 38 Symbol Table 39 Error Handling • Error handling and reporting also occurs across many phases – Lexical analyzer reports invalid character sequences – Syntactic analyzer reports invalid token sequences – Semantic analyzer reports type and scope errors • The compiler may be able to continue with some errors, but other errors may stop the process 40 Analysis of Source program Lexical Analyzer [ Scanner ] Syntax Analyzer [ Parser ] Semantic Analyzer [ Semantic Process ] Intermediate Code Generator Code Optimizer Tokens Parse tree Abstract Syntax Tree Non-optimized Intermediate Code Optimized Intermediate Code Code Generator Target machine code 41 The Grouping of Phases Compiler front and back ends: ◦ Front end: analysis (machine independent and Source language dependent) ◦ Back end: synthesis (machine dependent and Source language independent) Compiler passes: ◦ A collection of phases is done only once (single pass) or multiple times (multi pass) ◦ Single pass: usually requires everything to be defined before being used in source program ◦ Multi pass: compiler may have to keep entire program representation in memory 42 Other Tools that Use the Analysis- Synthesis Model 43444546 Compiler-Construction Tools Software development tools are available to implement one or more compiler phases ◦Scanner generators - Generate Lexical Analysis ◦Parser generators - Generate Syntax Analysis ◦Syntax-directed translation engines - Intermediate Code generation ◦Automatic code generators - Code Generation ◦Data-flow engines - Code Optimization 4748 Cousins of Compilers ❑Preprocessors ❑Compiler ❑Assemblers ❑Linkers ❑Loaders 49 Cousins of Compilers ▪Preprocessors ▪It converts HLL into pure HLL ▪It includes all the header files ▪It also expand shorthands, called macros, into source language statements ▪ It deals with macro-processing, augmentation, file inclusion, language extension, etc. ▪Compiler ▪It produces an assembly-language program 5051 Cousins of Compilers ▪Assembler ▪It is software which converts assembly code into object code, is called assembler. 5253 Cousins of Compilers ▪Linker ▪It resolves external memory addresses, where the code in one file may refer to a location in another file. ▪Loader ▪It puts the executable object files into memory for execution 5455 Cousins of Compilers Linking and loading It has four functions ▪ Allocation: It means get the memory portions from operating system and storing the object data. ▪ Relocation: It maps the relative address to the physical address and relocating the object code. ▪ Linker: It combines all the executable object module to pre single executable file. ▪ Loader: It loads the executable file into permanent storage. 56 A Language processing System Preprocessor Compiler Assembler Linker Skeletal Source Program Source Program Target Assembly Program Relocatable Object Code Absolute Machine Code Libraries and Relocatable Object Files 5758 Lexical Analysis Role of Lexical analyzer Tokens, Patterns and Lexemes Input Buffering Specification of Token Recognition of Token 59 The role of lexical analyzer Lexical Analyzer Parser Source program token getNextToken Symbol table To semantic analysis 60 Tokens, Patterns and Lexemes A token is a pair a token name and an optional token value A pattern is a description of the form that the lexemes of a token may take A lexeme is a sequence of characters in the source program that matches the pattern for a token 61 Example Token Informal description Sample lexemes if else comparison id number literal Characters i, f Characters e, l, s, e < or > or <= or >= or == or != Letter followed by letter and digits Any numeric constant Anything but “ sorrounded by “ if else <=, != pi, score, D2 3.14159, 0, 6.02e23 “core dumped” 62 Attributes for tokens E = M * C ** 2 ◦<id, pointer to symbol table entry for E> ◦<assign-op> ◦<id, pointer to symbol table entry for M> ◦<mult-op> ◦<id, pointer to symbol table entry for C> ◦<exp-op> ◦<number, integer value 2> 63 Example : E=M*C**2 SYMBOL TABLE 1 Id E ……… … 2 Id M 3 id C Lexical errors Some errors are out of power of lexical analyzer to recognize: ◦fi (a == f(x)) … However it may be able to recognize errors like: ◦d = 2r Such errors are recognized when no pattern for tokens matches a character sequence 65 Lexical errors Commonly generated lexical errors are - Spelling error - Unmatched Error - Appearance of illegal character - Exceeding length of the identifier Error recovery Panic mode: successive characters are ignored until we reach to a well formed token Delete one character from the remaining input Insert a missing character into the remaining input Replace a character by another character Transpose two adjacent characters 67 Input buffering Sometimes lexical analyzer needs to look ahead some symbols to decide about the token to return ◦ In C language: we need to look after -, = or < to decide what token to return ◦ In Fortran: DO 5 I = 1.25 We need to introduce a two buffer scheme to handle large look-aheads safely 68 Input buffering ▪Two buffer schemes • Buffer pair • Sentinels ▪Two pointers to the input are maintained: ▪LexemeBegin pointer ▪ Marks the beginning of the current lexeme ▪Forward pointer ▪ Scans ahead until a pattern match is found 69 Buffer Pair ◦ Each buffer is of the same size N ◦ N is the size of a disk block, eg. 4096 bytes ◦ eof marks the end of the source file 70 E = M * C * * 2 eof lexemeBegin Forward Buffer Pair 71 E = M * C * * 2 eof lexemeBegin Forward Input buffering Lexical Analyzer there are two pointers are used: ◦ Lexeme begin Pointer ◦ Forward Pointer ◦ Example: int main() { ……. …….. } Buffer Pairs 73 Lexeme Begin Pointer Forward Pointer i n t m a i n ( ) { } eof Buffer Pairs 74 Lexeme Begin Pointer Forward Pointer i n t m a i n ( ) { } eof Buffer Pairs 75 Lexeme Begin Pointer Forward Pointer i n t m a i n ( ) { } eof Sentinels Buffer test ▪one for the end of the buffer ▪One to determine what character is read Sentinels is a special character that cannot be part of the source program and natural choice is the character eof. lexemeBegin Forward E = M eof * C * * 2 eof eof 76 Sentinels Switch (*forward++) { case eof: if (forward is at end of first buffer) { reload second buffer; forward = beginning of second buffer; } else if {forward is at end of second buffer) { reload first buffer;\\ forward = beginning of first buffer; } else /* eof within a buffer marks the end of input */ terminate lexical analysis; break; cases for the other characters; } E = M eof * C * * 2 eof eof 77 lexemeBegin Forward Specifications of Tokens ❑Strings and Languages ❑Operations on Languages ❑Regular Expressions ❑Regular Definitions ❑Extensions of Regular Expressions 78 Strings and languages ▪Alphabet ▪ Is any finite set of symbols ▪ Eg: symbols are letters, digits and punctuation ▪ Eg: binary alphabet {0, 1} ▪String ▪ Is a finite sequence of symbols formed from that alphabet ▪ The length of a string s, |s|, is the number of occurrences of symbols in s ▪ Eg: banana, is a string of length six. ▪ Eg: ε , the string of length zero ▪Languages ▪ Language is any countable set of strings over some fixed alphabet. ▪ Eg: ∅ , the empty set or {ε } 79 Terms of string 1. Pre-fix of string s – removing zero or more symbols from the end of s 2. Suffix of string s – removing zero or more symbols from the beginning of s 3. Substring of s – deleting any prefix and any suffix from s 4. Proper prefixes, suffixes and substring of s – string that are not ε or not equal to s itself. 5. Subsequence of s – deleting zero or more not necessarily consecutive positions of s 80 Operations on Languages Operations on languages ▪Union ▪Concatenation ▪Closure (kleene) 81 Example: ▪L is Letter ▪D is Digit ▪L = { a, B, C ,…. , Z, a, b , c, …..z } ▪D = { 0, 1, 2, …. 9 } 8283 L U D LD L4 L* L(LUD)* D+ Regular Expressions Regular expressions used to specify tokens of a programming language. Example: RE for Identifier ◦ Letter_(letter_ | digit)* Each regular expression denotes a language. A language denoted by a regular expression is called as a regular set. 84 Regular Expressions (Rules) Regular expressions over alphabet  Reg. Expr Language it denotes Basis  {} a  {a} Induction: (r1) | (r2) L(r1)  L(r2) (r1) (r2) L(r1) L(r2) (r)* (L(r))* (r) L(r) (r)+ = (r)(r)* (r)? = (r) |  85 Regular Expressions We may remove parentheses by using precedence rules. ◦ * highest ◦ concatenation next ◦ | lowest ab*|c means (a(b)*)|(c) Ex: ◦  = {0,1} ◦ 0|1 => {0,1} ◦ (0|1)(0|1) => {00,01,10,11} ◦ 0* => { ,0,00,000,0000, ....} ◦ (0|1)* => all strings with 0 and 1, including the empty string ◦ 0|0*1 => {0, 1, 01, 001, 0001, …..} 86 Regular Expressions 87 Regular Definitions Regular definition Give names to regular expressions - Use these names as symbols to define other regular expressions. 88 Ex: Identifiers in Pascal letter → A | B | ... | Z | a | b | ... | z digit → 0 | 1 | ... | 9 id → letter (letter | digit ) * 89 Regular Definitions Ex: Unsigned numbers in Pascal digit → 0 | 1 | ... | 9 digits → digit + opt-fraction → ( . digits ) ? opt-exponent → ( E (+|-)? digits ) ? unsigned-num → digits opt-fraction opt-exponent Eg: 5280, 0.01234, 6.336E4 or 1.89E-4 90 Extensions of Regular Expressions ▪Zero or more instances ( * ) ▪One or more instances ( + ) ▪Zero or one instances ( ? ) ▪Character classes ▪Eg: [abc] - a|b|c ▪[a-z] - a|b|c|…|z 91 Recognition of tokens Starting point is the language grammar to understand the tokens: stmt -> if expr then stmt | if expr then stmt else stmt | Ɛ expr -> term relop term | term term -> id | number 92 Recognition of tokens The next step is to formalize the patterns: digit -> [0-9] Digits -> digit+ number -> digit(.digits)? (E[+-]? Digit)? letter -> [A-Za-z] id -> letter (letter|digit)* If -> if Then -> then Else -> else Relop -> < | > | <= | >= | = | <> We also need to handle whitespaces: ws -> (blank | tab | newline)+ 9394 Transition diagram for relop 95 Reserved words and identifiers id → letter (letter | digit ) * 96 Unsigned numbers  number -> digit(.digits)? (E[+-]? Digit)? 97 Transition diagram for whitespace  delimit -> (blank | tab | newline)  ws -> delimit + 98","libVersion":"0.5.0","langs":""}