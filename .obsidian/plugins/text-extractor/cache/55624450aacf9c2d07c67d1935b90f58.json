{"path":"sem5/OS/pdf/Module-5_Memory management.pdf","text":"Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Main Memory 9.2 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Outline  Background  Contiguous Memory Allocation  Paging  Structure of the Page Table  Swapping  Example: The Intel 32 and 64-bit Architectures  Example: ARMv8 Architecture 9.3 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Background  Program is permanently kept on backing store (disk)  For a program to be run it must be brought from backing store into memory and placed within a process  Main memory and registers are the only storage devices the CPU can access directly  Memory unit only sees a stream of: • addresses + read requests, or • address + data and write requests  Register access is done in one CPU clock (or less)  Main memory can take many cycles, causing a stall  Cache sits between main memory and CPU registers  Protection of memory is required to ensure correct operation 9.4 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Protection  Need to censure that a process can access only access those addresses in it address space.  We can provide this protection by using a pair of base and limit registers define the logical address space of a process 9.5 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Hardware Address Protection  CPU must check every memory access generated in user mode to be sure it is between base and limit for that user  The instructions to loading the base and limit registers are privileged 9.6 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Address Binding  Programs on disk, ready to be brought into memory to execute, are placed in an input queue • Without support, must be loaded into address 0000  Inconvenient to have first user process physical address always at 0000 • How can it not be?  Addresses represented in different ways at different stages of a program’s life • Source code addresses are usually symbolic • Compiled code addresses bind to relocatable addresses  i.e., “14 bytes from beginning of this module” • Linker or loader will bind relocatable addresses to absolute addresses  i.e., 74014 • Each binding maps one address space to another 9.7 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Binding of Instructions and Data to Memory  Address binding of instructions and data to memory addresses can happen at three different stages • Compile time: If memory location known a priori, absolute code can be generated; must recompile code if starting location changes • Load time: Must generate relocatable code if memory location is not known at compile time. Loader adds actual starting address. • Execution time: Binding delayed until run time if the process can be moved during its execution from one memory segment to another  Need hardware support for address maps (e.g., base and limit registers) 9.8 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Multistep Processing of a User Program 9.9 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Logical vs. Physical Address Space  The concept of a logical address space that is bound to a separate physical address space is central to proper memory management • Logical address – generated by the CPU; also referred to as virtual address • Physical address – address seen by the memory unit  Logical and physical addresses are the same in compile-time and load-time address-binding schemes; logical (virtual) and physical addresses differ in execution-time address-binding scheme  Logical address space is the set of all logical addresses generated by a program  Physical address space is the set of all physical addresses generated by a program 9.10 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Memory-Management Unit (MMU)  Hardware device that at run time maps virtual to physical address  Many methods possible, covered in the rest of this chapter 9.11 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Relocation Register  Consider simple scheme. which is a generalization of the base- register scheme.  The base register now called relocation register  The value in the relocation register is added to every address generated by a user process at the time it is sent to memory 9.12 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Relocation Register (Cont.)  The user program deals with logical addresses; it never sees the real physical addresses • Execution-time binding occurs when reference is made to location in memory • Logical address bound to physical addresses 9.13 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Dynamic Loading  The program consist of m ain part and a num ber of routines  The entire program does need to be in m em ory to execute  Routine is not loaded until it is called  Better m em ory-space utilization; unused routine is never loaded  All routines kept on disk in relocatable load form at  Useful when large am ounts of code are needed to handle infrequently occurring cases  No special support from the operating system is required • Implem ented through program design • OS can help by providing libraries to implem ent dynamic loading 9.14 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Dynamic Linking  Static linking – system libraries and program code combined by the loader into the binary program image  Dynamic linking –linking postponed until execution time  Small piece of code, called stub, is used to locate the appropriate memory-resident library routine  Stub replaces itself with the address of the routine, and executes the routine  Operating system checks if routine is in processes’ memory address • If not in address space, add to address space  Dynamic linking is particularly useful for libraries  System also known as shared libraries  Consider applicability to patching system libraries • Versioning may be needed 9.15 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Swapping  A process can be swapped temporarily out of memory to a backing store, and then brought back into memory for continued execution • Total physical memory space of processes can exceed physical memory  Backing store – fast disk large enough to accommodate copies of all memory images for all users; must provide direct access to these memory images  Roll out, roll in – swapping variant used for priority-based scheduling algorithms; lower-priority process is swapped out so higher-priority process can be loaded and executed  Major part of swap time is transfer time; total transfer time is directly proportional to the amount of memory swapped  System maintains a ready queue of ready-to-run processes which have memory images on disk 9.16 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Swapping (Cont.)  Does the swapped-out process need to swap back-in to same physical addresses?  Depends on address binding method • Plus consider pending I/O to / from process memory space  Modified versions of swapping are found on many systems (i.e., UNIX, Linux, and Windows) • Swapping normally disabled • Started if more than threshold amount of memory allocated • Disabled again once memory demand reduced below threshold 9.17 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Schematic View of Swapping 9.18 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Context Switch Time including Swapping  If next processes to be obtain CPU is not in memory, need to swap out a process and swap in target process  Context switch time can then be very high  100MB process swapping to hard disk with transfer rate of 50MB/sec • Swap out time of 2000 milliseconds • Plus swap in of same sized process • Total context switch swapping component time of 4000 milliseconds (4 seconds) 9.19 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Swapping (Cont.)  Other constraints on swapping • Pending I/O – can’t swap out as I/O would occur to wrong process • Or always transfer I/O to kernel space, then to I/O device  Known as double buffering, adds overhead  Standard swapping not used in modern operating systems • But modified version common  Swap only when free memory extremely low 9.20 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Swapping with Paging 9.21 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Swapping on Mobile Systems  Not typically supported • Flash memory based  Small amount of space  Limited number of write cycles  Poor throughput between flash memory and CPU on mobile platform  Instead use other methods to free memory if low • iOS asks apps to voluntarily relinquish allocated memory  Read-only data thrown out and reloaded from flash if needed  Failure to free can result in termination • Android terminates apps if low free memory, but first writes application state to flash for fast restart • Both OSes support paging as discussed below 9.22 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Memory Allocation  Main memory must support both OS and user processes  Limited resource, must allocate efficiently  Contiguous allocation is one early method  Main memory usually into two partitions: • Resident operating system, usually held in low memory with interrupt vector • User processes then held in high memory • Each process contained in single contiguous section of memory 9.23 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Contiguous Allocation  Relocation registers used to protect user processes from each other, and from changing operating-system code and data • Base register contains value of smallest physical address • Limit register contains range of logical addresses – each logical address must be less than the limit register • MMU maps logical address dynamically • Can then allow actions such as kernel code being transient and kernel changing size 9.24 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Variable Partition Allocation  Degree of multiprogramming limited by number of partitions  Variable-partition sizes for efficiency (sized to a given process’ needs)  Hole – block of available memory; holes of various size are scattered throughout memory  When a process arrives, it is allocated memory from a hole large enough to accommodate it  Process exiting frees its partition, adjacent free partitions combined  Operating system maintains information about: • (a) allocated partitions • (b) free partitions (hole) 9.25 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Dynamic Storage-Allocation Problem  First-fit: Allocate the first hole that is big enough  Best-fit: Allocate the smallest hole that is big enough; must search entire list, unless ordered by size • Produces the smallest leftover hole  Worst-fit: Allocate the largest hole; must also search entire list • Produces the largest leftover hole How to satisfy a request of size n from a list of free holes? First-fit and best-fit better than worst-fit in term s of speed and storage utilization 9.26 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Fragmentation  External Fragmentation – total memory space exists to satisfy a request, but it is not contiguous  Internal Fragmentation – allocated memory may be slightly larger than requested memory; this size difference is memory internal to a partition, but not being used  First fit analysis reveals that given N blocks allocated, 0.5 N blocks lost to fragmentation • 1/3 may be unusable -> 50-percent rule 9.27 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Fragmentation (Cont.)  Reduce external fragmentation by compaction • Shuffle memory contents to place all free memory together in one large block • Compaction is possible only if relocation is dynamic, and is done at execution time • I/O problem  Latch job in memory while it is involved in I/O  Do I/O only into OS buffers  Now consider that backing store has same fragmentation problems 9.28 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Segmentation  Memory-management scheme that supports user view of memory  A program is a collection of segments  A segment is a logical unit such as: main program procedure function method object local variables, global variables common block stack symbol table arrays 9.29 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition User’s View of a Program 9.30 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Logical View of Segmentation 1 3 2 4 1 4 2 3 user space physical m em ory space 9.31 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Segmentation Architecture  Logical address consists of a two tuple: <segment-number, offset>  Segment table – maps two-dimensional physical addresses; each table entry has: • base – contains the starting physical address where the segments reside in memory • limit – specifies the length of the segment  Segment-table base register (STBR) points to the segment table’s location in memory  Segment-table length register (STLR) indicates number of segments used by a program • Segment number s is legal if s < STLR 9.32 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Segmentation Hardware 9.33 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Paging  Physical address space of a process can be noncontiguous; process is allocated physical memory whenever the latter is available • Avoids external fragmentation • Avoids problem of varying sized memory chunks  Divide physical memory into fixed-sized blocks called frames • Size is power of 2, between 512 bytes and 16 Mbytes  Divide logical memory into blocks of same size called pages  Keep track of all free frames  To run a program of size N pages, need to find N free frames and load program  Set up a page table to translate logical to physical addresses  Backing store likewise split into pages  Still have Internal fragmentation 9.34 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Address Translation Scheme  Address generated by CPU is divided into: • Page number (p) – used as an index into a page table which contains base address of each page in physical memory • Page offset (d) – combined with base address to define the physical memory address that is sent to the memory unit  For given logical address space 2m and page size 2 n 9.35 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Paging Hardware 9.36 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Paging Model of Logical and Physical Memory 9.37 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Paging Example  Logical address: n = 2 and m = 4. Using a page size of 4 bytes and a physical memory of 32 bytes (8 pages) 9.39 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Free Frames Before allocation After allocation 9.40 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Implementation of Page Table  Page table is kept in main memory • Page-table base register (PTBR) points to the page table • Page-table length register (PTLR) indicates size of the page table  In this scheme every data/instruction access requires two memory accesses • One for the page table and one for the data / instruction  The two-memory access problem can be solved by the use of a special fast-lookup hardware cache called translation look- aside buffers (TLBs) (also called associative memory). 9.41 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Paging Hardware With TLB 9.42 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition • Each entry in the TLB consists of two parts: a key (or tag) and a value. • The TLB contains only a few of the page-table entries. • When a logical address is generated by the CPU, its page number is presented to the TLB. If the page number is found (TLB HIT), its frame number is immediately available and is used to access memory. • If the page number is not in the TLB (TLB miss), a memory reference to the page table must be made. When the frame number is obtained, we can use it to access memory. • The percentage of times that the page number of interest is found in the TLB is called the hit ratio. • The access time of a byte is said to be effective when the TLB hit ratio is high. • Thus the effective access time is given by Effective access time = TLB hit ratio* Memory access time +TLB miss ratio* (2*memory access time) 9.43 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Effective Access Time  Hit ratio – percentage of times that a page number is found in the TLB  An 80% hit ratio means that we find the desired page number in the TLB 80% of the time.  Suppose that it takes 10 nanoseconds to access memory. • If we find the desired page in TLB then a mapped-memory access take 10 nanoseconds • Otherwise we need two memory access so it is 20 nanoseconds  Effective Access Time (EAT) EAT = 0.80 x 10 + 0.20 x 20 = 12 nanoseconds implying 20% slowdown in access time  Consider a more realistic hit ratio of 99%, EAT = 0.99 x 10 + 0.01 x 20 = 10.1 nanoseconds implying only 1% slowdown in access time. 9.44 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Memory Protection  Memory protection implemented by associating protection bit with each frame to indicate if access is allowed  Valid-invalid bit attached to each entry in the page table: • “valid” indicates that the associated page is in the process’ logical address space, and is thus a legal page • “invalid” indicates that the page is not in the process’ logical address space • Or use page-table length register (PTLR)  Any violations result in a trap to the kernel  Can also add more bits to indicate if read-only, read-write, execute-only is allowed. 9.45 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Valid (v) or Invalid (i) Bit In A Page Table 9.46 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Shared Pages  Shared code • One copy of read-only (reentrant) code shared among processes (i.e., text editors, compilers, window systems) • Similar to multiple threads sharing the same process space • Also useful for interprocess communication if sharing of read-write pages is allowed  Private code and data • Each process keeps a separate copy of the code and data • The pages for the private code and data can appear anywhere in the logical address space 9.47 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Shared Pages Example 9.48 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Structure of the Page Table  Memory structures for paging can get huge using straight-forward methods • Consider a 32-bit logical address space as on modern computers • Page size of 1 KB (210) • Page table would have 1 million entries (232 / 210) • If each entry is 4 bytes  each process requires 16 MB of physical address space for the page table alone  Don’t want to allocate that contiguously in main memory • One simple solution is to divide the page table into smaller units  Hierarchical Paging  Hashed Page Tables  Inverted Page Tables 9.49 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Hierarchical Page Tables  Break up the logical address space into multiple page tables  A simple technique is a two-level page table  We then page the page table 9.50 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Two-Level Paging Example  A logical address (on 32-bit machine with 1K page size) is divided into: • a page number consisting of 22 bits • a page offset consisting of 10 bits  Since the page table is paged, the page number is further divided into: • a 12-bit page number • a 10-bit page offset  Thus, a logical address is as follows:  where p1 is an index into the outer page table, and p2 is the displacement within the page of the inner page table  Known as forward-mapped page table 9.51 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Address-Translation Scheme 9.52 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition 64-bit Logical Address Space  Even two-level paging scheme not sufficient  If page size is 4 KB (212) • Then page table has 252 entries • If two level scheme, inner page tables could be 210 4-byte entries • Address would look like • Outer page table has 242 entries or 244 bytes • One solution is to add a 2nd outer page table • But in the following example the 2nd outer page table is still 234 bytes in size  And possibly 4 memory access to get to one physical memory location 9.53 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Three-level Paging Scheme 9.54 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Hashed Page Tables  Used in architecture with address spaces > 32 bits  The virtual page number is hashed into a page table • This page table contains a chain of elements hashing to the same location  Each element contains 1. The virtual page number 2. The value of the mapped page frame 3. A pointer to the next element  Virtual page numbers are compared in this chain searching for a match • If a match is found, the corresponding physical frame is extracted 9.55 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Hashed Page Tables (Cont.)  Variation for 64-bit addresses is clustered page tables • Similar to hashed but each entry refers to several pages (such as 16) rather than 1 • Especially useful for sparse address spaces (where memory references are non-contiguous and scattered) 9.56 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Hashed Page Table 9.57 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Inverted Page Table  Rather than having each process keep a page table and track of all possible logical pages, track all physical pages  One entry for each real page of memory  Entry consists of the virtual address of the page stored in that real memory location, with information about the process that owns that page  Decreases memory needed to store each page table, but increases time needed to search the table when a page reference occurs  Use hash table to limit the search to one (or at most a few) page- table entries • TLB can accelerate access  But how to implement shared memory? • One mapping of a virtual address to the shared physical address 9.58 Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition Inverted Page Table Architecture Silberschatz, Galvin and Gagne ©2018Operating System Concepts – 10 th Edition End of Chapter","libVersion":"0.5.0","langs":""}